标准输入输出
	在iostream头文件中, 包含4个标准输入输出, 分别是cin, cout, cerr, clog, 大致与C相同,注意
	上述4个全部在std的名字空间中, 使用需要std::
	输入或者输出使用>>和<<, 可以将变量和字符串一同输出, 两个运算符会自动判断变量类型
	std::endl用于结束行和刷新缓冲区, 在使用输出调试程序时, 要注意及时刷新

标准输入输出的值
	如果成功的读取一个类型匹配的值, 则表达式返回真, 否则返回假
	可以通过此条件实现输入次数未知的数据读取

如何输入EOF
	Windows下输入ctrl+z, linux输入ctrl+d

输入输出重定向
	在命令行中使用如下格式, 可以对程序的输入和产生的输出进行重定向
	a.exe <infile.txt >outfile.txt

如何选择数据类型
	明确没有负数时, 使用无符号数
	执行整数运算使用int, 如果超过int, 使用long long（因为long的大小在不同机器上难以确定）
	浮点计算使用double（因为float精度有限, 且double计算的损失不比float大很多）
	如果要是有小的数字, 尽量选择unsigned char, 不同机器上char是否有符号不确定

隐含类型转化问题
	参照《CSAPP》, 按照机器码计算, 不过为了避免这些坑, 最好能统一

字面常量
	即在代码中直接出现的数值, 各种进制的输入方式与C相同, 注意, 字面上的十进制值通常都是有符号的, 而八进制和十六进制可以是没有符号的, 如果最大的类型都无法容纳, 则产生错误. 后缀用法与C相同

字符串字面值
	和字面常量类型, 特别地, 当两个字符串字面值位置紧邻且仅由空格, 缩进和换行符分割, 则他们实际上是一个整体
初始化
	与C相比, C++有四种初始化的方式
	int units_sold = 0;
	int units_sold = {0};
	int units_sold{0};
	int units_sold(0);	
	注意, 在使用第二种方法时, 编译器会拒绝信息丢失, 例如将double赋值给int
	无论是C还是C++, 在初始化的时候, 都不能使用连等

默认初始化
	指如果变量没有被定义时, 默认的值
	在所有函数外部定义的变量, 默认为0
	在函数内定义的值不被初始化, 其值未定义
	类的默认值由类决定

变量命名
	规则与C相同, 同样注意避开两个下划线开头和下划线紧跟大写字母开头的容易和标准库冲突的名称
	通常普通变量使用小写字母, 类名大写第一个字母

变量作用域
	规则与C相同, 但是可以使用作用域操作符::来 强制使用 某个被内部变量覆盖的 外部变量
	全局作用域本身没有名字, 在::左侧为空, 表示全局作用域

引用（左值引用）
	创建一个变量的别名, 之后这个别名将和变量完全捆绑在一起
	int val = 1
	int &refval = val
	即, 创建一个val的别名reval, 之后对reval的任何操作与对val相同
	注意：因为之后不可指向其他对象, 所以必须初始化
	可以在一句中定义多个引用和变量, 但每个引用都必须以&开头

指针
	指针定义方式与C相同, 在一句中可以定义多个指针, 但每个都要以*（星号）开头
	注意：引用不是对象, 所以不能产生指向引用的指针（不能取地址）

nullptr
	C++11新增的关键字, 是字面常量, 表示空指针, 相当于C中的NULL
	C++中的NULL在cstdlib中定义,同时在C++代码中, 应该避免使用NULL

理解复合类型声明
	实际上在一句中可以定义多个不同类型的变量, 例如
	int i = 1024, *p=&i,&r=i;
	实际上数据类型都是int, *和&是对具体变量的修饰

指向指针的指针
	用法与C一致

指向指针的引用
	int *p;
	int *&r = p; 	//产生了一个指针的引用
	对于两个符号的顺序, 要记住r实际上是指针的别名

const常量
	在编译器的编译过程中, 编译器会将所有的常量出现的地方替换成对应的值
	因为多文件中, 变量通常都是不能直接访问的, 因此const的常量也是文件作用域
	如果确实需要在不同文件中共享常量, 可以在所有的文件中, 加上extern定义
	（效果与原因不明, 稍后处理）P54

const的引用
	对const的引用也需要加上const关键字, 例如
	const int c = 1024;
	const int &r =  c;
	不加const的对const的引用是错误的

const引用的例外
	对于一个const引用, 初始化时, 可以使用其他类型的数据, 例如
	const int的引用可以使用int或者double赋值
	此时const只是表示, 不通过此引用修改对应数据的值, 但是数据可以通过其他方式改变
	此外, const引用还可以应用字面值

指向const的指针
	定义格式与引用相同, 同样只是表示不通过此指针修改指向对象的值, 而该对象可以通过其他方式改变

const指针
	即指针本身是常量, 定义时, const位于*与指针名之间, 例如
	int a = 10;
	int * const ptr = &a;

理解复杂定义的方式
	从右向左阅读, 例如
	int *&r = p; r先是一个引用, 然后说明是指针的引用, 最后说明是int的指针
	int * const ptr = &a;ptr先是常量, 然后说明是一个int的指针

顶层const与底层const
	顶层const表示对象是常量, 底层const表示指针指向的对象是常量
	注意：顶和底和const位置没有联系
	在拷贝操作中, 通常顶层const没有限制, 而如果有底层const, 那么两个变量都有底层const, 或者可以转换
	即, 变量可以转化为常量, 如可以把int * 赋给const int *

constexpr
	功能暂不明确
	P58

类型别名
	有两种方法可以产生数据类型的别名, 传统的是使用typedef, 新方法是使用using, 例如
	using SI = Sales_item; 将SI作为Sales_item的别名
	使用替换以后和const的组合可能会产生误解, 不要用替换回来的方式理解, 因为这不是文本替换

auto类型
	注意：启用该特征需要使用IOS C++11标准
	与C定义不同, auto表示有编译器自动从初始化的表达式中判断类型
auto与const
	编译器自动推断时, 会进行一定的转换, 通常会忽略顶层const, 而保留底层const
	如果需要顶层const, 可以在auto前加上const修饰符(这样这个量会变成常量, 但是指向的量不是, 所以不能对迭代器使用)
	但是 如果是引用, 则会保留顶层const
auto与引用
	auto的变量如果接受的值是一个引用, 会变成引用的对象的类型, 如果需要变成引用, 应该显式声明, 例如
	auto &v = i;

decltype
	返回操作数的类型, 例如
	decltype(f()) sum = x;
	则sum的类型为函数f（）返回值的类型, 如果操作数是变量, 则会保留所有的const
	注意：如果操作数是引用, 则返回引用类型, 而不是引用对应的类型
	      同理操作数是使用解引用操作的指针, 返回的类型也是引用类型
	注意：如果对表达式使用, 有没有括号时不一样的
	      如果是单独的变量, 则返回变量的类型, 如果给变量加上括号, 则会返回引用类型

赋值表达式的类型
	赋值表达式是典型的引用类型, 类型时左值的类型

结构
	定义方法与C相同, 但是在声明新的结构变量时, 不需要再加上struct
	同时C++11标准, 允许在结构定义时对其初始化, 未初始化的变量将默认初始化
	注意：不能使用圆括号初始化

命名空间的using用法
	using namespace::name;
	注意：如果要加入多个名字, 每个名字前面都需要using
	之后就可以直接使用这些名字
	注意：在头文件中, 应该避免使用using, 以免造成难以预料的名字冲突

标准库类型string
	通常使用前需要包含以下代码
	#include <string>
	using std::string;

string初始化方法
	string s1		默认初始化, s1为空
	string s2(s1)		s2时s1的副本
	string s2 = s1		与上面的方式等价
	string s3("value")	是字面值"value"的副本, 同时还包含一个\0
	string s3 = "value"	与上面的方式等价
	string s4(n,'c')	初始化为连续的n个'c'

string操作
	os<<s			将s写入输出流os, 返回os
	is>>s			将is中的字符串赋给s, 返回is
	getline(is,s)		读取is中的一行, 赋给s
	s.empty()		判断s是否为空
	s.size()		返回s中字符个数
	s[n]			返回s中第n字符的引用
	s1+s2			前后连接
	s1=s2			赋值
	s1==s2			比较相等,比较内容而不是比较地址
	s1!=s2			比较不等
	<,<=,>,>=		按照字典顺序比较, 可能还是安装ASCII码比较

读写string
	读入时, 会自动忽略开头的空白, 读取到下一个空白停止, 例如
	"       Hello World!     "
	读取后, 会变成"Hello"

使用getline读取
	会读取到换行符结束, 换行符也会被读入, 但是不会被存入目标的string中
	所以, 如果只有一个换行符, 则返回空string
	只有遇到EOF才返回0,可以以同样的方法进行判断结束

size()函数返回的类型
	size()返回string::size_type, 虽然不太清楚这个类型的细节, 但是可以使用auto, 例如
	auto len = line.size();
	显然返回值肯定时无符号数, 所以在表达式中, 应该避免混入非unsigned的值

字面值和string相加
	实际上, 字符串的字面值与C中一样, 时char*, 所以当字面值和string相加时, 字面值会转化为string
	但是两个字面值不能相加, 同样有多个混合相加时, 要考虑计算顺序
	即从左向右, 这样处理是为了和C兼容

C++中来自C头文件的一般规则
	一般在C中name.h头文件在C++中改为cname头文件, 其中开头的c表示继承自C
	注意：早cname中定义的名字都在std空间中, 因此在C++中, 应该避免使用C头文件, 以便于管理
	
cctype头文件
	与C中ctype.h头文件相同, 用于字符处理, 包含相当多有关的函数
 函数名称         返回值

 isalnum()	 如果参数是字母数字, 即字母或数字, 该函数返回 true
 isalpha()	 如果参数是字母, 该函数返回 true
 isblank()	 如果参数是空格或水平制表符, 该函数返回 true
 iscntrl()	 如果参数是控制字符, 该函数返回 true
 isdigit()	 如果参数是数字 (0~9), 该函数返回 true
 isgraph()	 如果参数是除空格之外的打印字符, 该函数返回 true
 isprint()	 如果参数是打印字符 (包括空格), 该函数返回 true
 ispunct()	 如果参数是标点符号, 该函数返回 true
 isspace()	 如果参数是标准空白字符, 如空格、进纸、换行符、回车、水平制表符或垂直制表符, 
		 该函数返回 true
 islower()	 如果参数是小写字母, 该函数返回 true
 isupper()	 如果参数是大写字母, 该函数返回 true
 isxidgit()	 如果参数是十六进制的数字, 即 0~9, a~f 或 A~F, 该函数返回 true
 tolower()	 如果参数是大写字母, 输出小写字母, 否在原样输出
 toupper()	 如果参数是小写字母, 输出大写字母, 否在原样输出

基于范围的for语句
	这是C++11的新特征
	for(declaration:expression)
		statement
	expression是一个对象, 用于表示一个序列
	declaration用于初始化一个变量, 每次迭代, 该变量会被 初始化 为expression的下一个字符
	例如
	srting s("Hello World!!!")		//新的初始化方式
	decltype(s.size()) punt_cnt = 0;	//使punt_cnt与size()返回值类型相同
	for (auto c : s)			//自动判断类型, 在此处实际上是char
		if(ispunct(c))
			++punt_cnt;
	cout << punt_cnt << "punctuation characters in"
	     << s << endl;	

使用基于范围的for语句改变字符串中的值
	因为只是初始化为expression的下一个字符, 所以不能通过那个变量, 改变字符串的值
	如果需要改变, 需要声明成引用, 例如
	for(auto &c : s)
	即可通过c改变s的值
	
标准库类型vector
	通常需要以下代码
	#include <vector>
	using std::vector;
	是表示对象的集合, 其中所有的对象类型都相同, 也被称为容器（container）

vector实例化
	实际上vector是类模板, 相当于编译器生成类或函数的说明
	使用模板时, 需要指明编译器应该实例化成何种类型, 例如
	vector<int> ivec;		//即ivec保存int型对象
	也可以将模板实例化成其他模板, 例如
	vector<vector<int> > file	//即file保存vector<int>对象
	注意：在过去的编译器中右侧的两个括号之间需要空格
	
vector初始化
	vector<T> v1			v1为空vector, 潜在元素是T类型, 默认初始化
	vector<T> v2(v1)		v2是包含v1全部元素的副本
	vector<T> v2 = v1		与上面的方式等价
	vector<T> v3(n,val)		v3包含n个重复的元素val
	vector<T> v4(n)			v4包含n个重复的执行了初始化的对象
	vector<T> v5{a,b,c...}		v5包含相应值的元素
	vector<T> v5={a,b,c...}		与上面的方式等价

值初始化
	如果实例时, 只提供数量, 而不提供大小时, 被编译器赋予一个初始值
	如果是内置类型, 比如int, 会被默认初始化为0, 类按照构造函数初始化, 如果类不能明确默认初始化的值, 则必须给出初始化的值
	     
使用圆括号还是花括号
	注意：
	vector<int> v1(10,1)		//表示初始化10个1
	vector<int> v2{10,1}		//表示初始化10和1
	如果是string, 则全部都是花括号, 例如：
	vector<string> v3{10}		//表示初始化10个空字符串
	vector<string> v4{10,"hi"}	//表示初始化10个"hi"
	注意：
	vector也可以在列表中, 用变量初始化, 只要变量类型符合, 错误提示为：
	could not convert XXX from '<brace-enclosed initializer list>' to 'std::vector<int>'

向vector中添加元素
	使用成员函数push_back,把一个值当作vector对象压入尾端
	实际上vector具有高性能的增长能力, 因此, 事先确定其大小往往是没有必要的
	先创建一个空vector, 然后在使用过程中不断添加是较好的选择


vector对象操作
pop_back()	弹出最后的一个元素, 返回值为void
at(i)		访问索引为i的元素, 会进行边界检查
clean()		清空所有元素
insert（iterator it,const T& x）	在迭代器指定的位置插入一个元素x
insert（iterator it,, size::type n,const T& x）
eraser(iterator it)			在迭代器指定的位置删除一个元素x
eraser(iterator first,iterator last)
	其余操作与string相同, 也可以使用范围for循环对其遍历, 如果循环体中, 包含向vector添加元素的语句, 则不能使用范围for循环
	size()函数返回的类型来自对应的名字空间, 例如
	vector<int>::size_type

嵌套vector操作
	即一个vector的内部的数据也是vector, 可以先定义一个和内部vector相同的临时vector
	push满了以后, 再把这个vector作为参数push到嵌套的vector中

迭代器
	实际上大概是一种特殊的指针, string和vector都支持迭代器
	使用成员函数begin（）和end（）来返回一个迭代器, 可以使用auto来自动获得类型
	迭代器操作与指针相同, 如 *,->,++,--, ==, !=等
	如果为空, 则begin（）与end（）返回相同值, 否则begin（）指向第一个元素, end（）指向最后一个元素的下一个元素
	注意：因为可以用.运算符访问成员函数, 所以迭代器可以使用->访问
	注意：使用了迭代器的循环体中, 不应该添加新元素（因为指针可能会失效）

泛型编程
	实际上并不是所有容器的迭代器都定义了<或者>运算, 所以C++中往往使用!=v.end()来控制循环
	这样就不用在意容器的迭代器是否支持<或者>运算

迭代器类型
	实际上, 并不需要知道迭代器到底是什么类型, 但其类型名字来自于
	vector<int>::iterator			string::iterator
	vector<int>::const_iterator		string::const_iterator

常量迭代器
	即只读的迭代器, 通常使用auto时, 迭代器返回值有对象的元素决定, 当对象为常量时, 才返回常量迭代器
	C++11新增cbegin（）与cend（）成员函数, 返回常量迭代器

vector和string特有的迭代器运算
	iter + n		返回一个迭代器, 位置向前移动n个元素
	iter - n		返回一个迭代器, 位置向后移动n个元素
	iter += n		复合语句, 效果类似
	iter -= n		复合语句, 效果类似
	iter1 - iter2		返回连个迭代器的距离, 必须指向同一容器
	>,>=,<,<=		与通常意义下的定义一致
	注意：迭代器的差是difference_type类型, 名字在对应的名字空间中

数组
	数组大小固定, 所以在某些应用中效率更好, 入宫大小不确定, 应该使用vector（这大概就是为什么C++不支持变长数组的原因）
	可以使用字符串字面值对char数组初始化

指针数组, 数组应用
	P102

标准库函数begin（）和end（）
	参数是数组名, 返回对应的迭代器

与旧代码的借口
	C++中的string与C中的字符串有很多不同, 将C字符串转化为string是自动的（赋值和运算）
	string可以调用c_str()成员函数来返回一个char * , 从而与原有的C兼容
	
	C++中的vector与C的数组有很多不同, 可以用数组为vector赋值
	int int_arr[] = {0,1,2,3,4,5,6};
	//指明要复制的区域的首尾即可
	vector<int> ivec(begin(int_arr),end(int_arr));

建议	
	尽量使用vector和迭代器替代原有的指针和内置数组

多维数组
	多位数组定义和初始化与C相同

size_t类型
	使用数组下标时, 通常定义为size_t类型, 其为一种与机器有关的无符号类型, 被设计的足够大以能表示内存中任意对象的大小
	在头文件cstddef中定义了size_t类型（实际测试相当于unsigned long long）（不需要include cstddef）

使用范围for循环处理多位数组
	size_t cnt = 0;
	
	for(auto &row : ia)
		for(auto &col : row){
			col = cnt;
			++cnt;
		}
	第一次使用引用, 产生一个数组, 在第二层中, 再在数组中遍历
	如果需要只读, 可以查看auto与const的部分

左值与右值
	简单说, 一个对象作为左值时, 用的是它的值, 作为右值时, 用的是它的身份（内存中的位置）

算数运算符说明
	大部分和C一致, 对于取余, 新标准规定
	m % (-n) = m % n,(-m) % n = -( m % n )
	即, 余数重视和m符号保存相同

逻辑运算符说明
	与C没有区别, 需要强调, &&和||都是先求左侧运算对象的值, 当无法确定表达式值时再求右侧的值
	因此这个条件可以控制指针越界的问题


使用引用来避免拷贝
	例如对一个包含string的vector, 使用范围for循环时, 使用引用可以避免对这些string的拷贝, 从而提升效率

相等性测试与布尔字面值
	除非变量本身就是布尔型, 否则不应该将其与ture或false比较
	直接将数值当作布尔值用于if中的判断是可以接受且简单的
=>推荐的写法
	while（(i=getvalue()) != 0）{....
	从而使条件获得更好的体现

递增与递减运算符
	如果不是必须, 尽量使用前置运算符, 因为使用后置运算符需要保存原始值, 
	对于复杂的迭代器, 会产生巨大的性能损失

条件运算符
	使用?:可以适当化简, 但是其优先级非常地低, 在嵌套语句中, 应该两端括号

位运算
	完全与C一致, >>和<<实际上是IO库的重载, 位运算细节参考《CSAPP》
	安全起见, 尽量使用位运算处理无符号数

sizeof运算符
	有两种形式sizeof（type）, sizeof expr
	使用第二种形式返回表达式结果的大小, 所以如果expr是  解引用  的指针, 则返回指针指向的数据的大小
	（实际上就是和其他一样理解）
	注意, sizeof不会对表达式求值, 因此即使解引用无效的指针, 也不会产生问题
	如果对数组使用, 会返回数组的大小, 但是对string和vector使用, 只是返回固定部分的大小
	（固定部分意义不太明确, 反正不是实际大小）

逗号表达式
	可以用于在while语句的变量递增的部分写多个表达式

指针的转化
	常量整数值0和字面值nullptr可以转化为任意指针类型, 任意非常量指针可以转化为void*
	指向任意对象的指针可以转化为const void*

强制类型转换
	注意：这种行为是十分危险的（破环了类型检查机制）, 如非必要, 不要使用
	
命名的强制类型转换
	cast-name<type>(expression);
	其中cast-name是static_cast,dynamic_cast,const_cast,reinterpret_cast
static_cast
	任何具有明确定义的类型转换, 只要不包含底层const（指针指向的对象）, 例如
	int i=3,j=5;
	double slope = static_cast<double>(j)/i    //将j转化为double类型

const_cast
	改变运算对象的底层const, 例如
	const char *pc;
	char *p = const_cast<char *>(pc);
	如果pc指向常量, 则通过p向其写入是未定义的, 但如果本身就不是常量, 使用强制转化获得写权限是合法的
	注意：只能改变const不能改变类型

dynamic_cast
	支持运行时类型识别, 具体内容见后续章节

reinterpret_cast（十分危险！）
	可以为运算对象的位模式提供低层次上的重新解释, 例如
	int *ip;
	char *pc = reinterpret_cast<char*>(ip);		//从int指针变成char指针
	转化的结果依赖机器, 尽量避免使用
=>建议：
	在有函数重载的上下文中使用const_cast无可厚非, 但是在其他情况下使用const_cast, 也就意味着程序设计存在缺陷
	其他的强制类型转换, 也不应该频繁使用. 每次写时, 应该考虑是否能用其他方法代替
	实在不能替代, 也应该尽可能限制其作用域, C的强制类型转换更不易察觉, 更加要避免

switch语句
	因为C/C++不严格要去缩进, 因此如果共享多个标签时, 可以把它们写在一行, 以凸显共享
	建议在最后一个case中也加上break语句, 从而避免以后加入新的case时, 忘记给原来的case加上break
	即使default情况什么也不做, 也可以加上, 以提示读者考虑了默认情况, 只是什么都不做而已

try语句块和异常处理
throw表达式
	throw后跟上一个表达式, 例如
	throw runtime_error("Data must reger to same IBSN");
	其中, runtime_error是标准库异常类型的一种, 包含在stdexcept头文件中
	通过提过一个string对象为其初始化, 该string包含错误的具体信息

try语句
	try{
		program-statements
	}catch(exception-declaration){
		handler-statements
	}catch(exception-declaration){
		handler-statements
	}
	注意, 每个字句都是语句块, 所以在try内声明的变量, 在catch语句中也不能访问

函数在寻找处理代码的过程
	如果在一处代码中抛出了错误, 则会在该函数中寻找对应的catch语句, 如果没有, 该函数将被终止, 并向调用该函数的函数中寻找
	如果最终也没有找到任何匹配的catch语句, 程序转到名为terminate的标准库函数
	该函数行为与系统有关, 通常执行该函数将导致程序非正常退出

标准异常
	C++中定义的一组类, 用于报告标准库函数遇到的问题, 这些异常类也可以在用于编写的程序中使用
	exception头文件中定义了最通用的异常类exception. 它只报告异常发生, 不提供任何额外的信息
exception		最常见错误

	stdexcept头文件提供了几种常用的异常类, 具体如下
runtime_error		只有在运行中才能检查的错误
range_error		运行时错误：生成的结果超过有意义范围
overflow_error		运行时错误：计算上溢
underflow_error		运行时错误：计算下溢

logic_error		程序逻辑错误
domain_error		逻辑错误：参数对应结果值不存在
invalid_argument	逻辑错误：无效参数
length_error		逻辑错误：试图创建一个超出该类型最大长度的对象
out_of_range		逻辑错误：使用一个超出有效范围的值

	除了exception意外上述的其他异常都必须通过string初始化
	这些异常只定义了一个名为what（）的成员函数, 该函数没有参数, 返回一个const char *, 指向关于异常的文本信息

自定义的异常
	通常是继承某一个标准异常, 如果只是提供一个新的名称, 那么就不需要自己再其他任何成员
	自需要调用继承的构造函数, 为基类构造就可以了
自定义的其他异常
	还可以创建其他的成员函数, 然后这些成员在catch语句捕捉该异常后, 和what函数一样的可以被调用

函数的参数列表
	如果函数没有参数, 使用空括号即可, 不过为了和C兼容, 使用void也可以
	形参名是可选的, 通常如果传入的参数不使用, 可以不为其命名, 以显示函数体内不适应它

参数传递
	普通的参数传递和指针的传递与C一致, C++补充传引用参数
	函数声明
		void reset(int &i){
			i = 0;
		}
	之后可以
		int j =42;
		reset(j);
	此时i相当于只是j的一个别名, 修改i可以直接影响到j
	使用引用可以避免参数传递过程的拷贝, 如果不需要修改参数, 应该声明为const的引用
	
回顾const的关系
	具有相同底层const才能拷贝, 因此普通指针不能被const指针赋值, 不能被const变量赋值
	但是因为一般来说, 非常量可以转化为常量
	因此底层const指针可以被普通指针赋值, 被普通变量赋值
	故曰：底层const只是指针自认为自己指向const, 从而去修改他	
		引用规则同理
	注意：除了const的引用以外, 其他引用均不可以用字面值初始化

函数参数声明规则
	有上述规则可见, 把不需要改变的参数声明为const除了安全以外, 还可以避免因为是普通参数而不能接受const量

使用应用传递数组
	数组的传递与C一样, 只传递首地址指针, 因此可以使用引用来传递数组
	void print(int (&arr)[10]){
		for (auto elem ：arr）
			cout << elem

数组应用规则回顾
int (&arr)[10]		引用一个有十个元素的数组
int &arr[10]		包含十个引用的数组
int (*arr)[10]		指向一个十个元素的指针
int *arr[10]		包含十个指针的数组

命令行参数
	包括可执行文件的名称在内的所有参数都会存入数组, 同时数组最后一个元素为0, argc为不包括0在内的数组个数
	因此参数范围是i=1,i<argc

可变参数的函数
	方法一：p618
	方法二：传递一个类似列表的数据结构
initializer_list
	用于表示特定类型值的数组, 和vector一样需要声明具体数据类型, 赋值以及迭代器的操作与vector相同
	但是initializer_list中的每一个元素都是const的
	使用initializer_list作为形参的函数可以使用字面的vector赋值, 如{"functionX","break"}

返回引用的函数
	返回的引用可以作为左值, 例如
	char %get_val(string &str,string::size_type ix){
		return str[ix];
	}
	之后可以使用如
	string s("a string");
	get_val(s,0) = 'A';
	注意, 和指针一样, 返回局部变量的引用是没有意义的

列表初始化返回值
	即将vector作为返回值
	vector<string> process(){
		...
		//expected与autual是string对象
		if(expected.empty())
			return {};				//返回空vector对象
		else if(expected == autual)
			return {"functionX","ok"};		//返回列表初始化的vector对象
		else
			return {"functionX",expected,actual}

main函数的return
	main函数中如果没有return, 当指向到函数末尾时, 编译器会自动加上return 0 语句

使用类型别名
	typedef int arrT[10];	
	using arrT = int[10];	//两种方法中arrT都表示是10个int的数组
	arrT * func(int i);

声明一个返回数组指针的函数与使用尾置返回类型
	P205-206

函数重载
	如果同一作用域内的几个函数名字相同, 但参数列表不同, 则称之为函数重载
	因为变量可以向常量转化, 因此只有底层const不同才能重载

const_cast和重载
	如果一个接受const并返回const的函数, 需要重载成接受普通参数, 并返回普通参数, 
	则可以重载一个接受普通参数的函数, 然后用const_cast强制转化, 再调用原来的函数, 最后在转化回来
	因为本来就不是const的, 所以这样转化是安全的

	//函数一 
	const string &shorterString(const string &s1,const string &s2){
		return s1.size() <= s2.size() ? s1 : s2;
	}
	//函数二 
	string &shorterString(string &s1,string &s2){
		auto &r = shorterString(const_cast<const string&>(s1),
								const_cast<const string&>(s2));
		return const_cast<string&>(r);
	}

重载与作用域
	和变量一样, 如果在内部的作用域中有新的函数声明, 则原来所有的同名函数都会被覆盖, 在局部作用域中声明函数是反常规的

默认实参
	例如 string screen(sz ht = 24,sz wid = 80,char backgrand = ' ')
	注意：
	1.一旦开始使用默认参数, 则之后的所有参数都需要有默认参数
	2.只能省略右侧空出来的参数, 因此要合理设计参数位置, 把最容易默认的参数放在最右边
	3.重复声明函数时, 默认参数不能不能被重复赋值
	4.注意在头文件中定义了默认参数以后, 在函数定义时, 不要再加上, 否则是重复定义默认参数

内联函数
	定义与C相同, 适用于规模小, 流程直接的函数

arrert预处理宏
	还是自行Google

重载函数的匹配
	需要满足一下要求
	1.该函数买个实参的匹配不劣于其他函数
	2.该函数至少有一个参数优于其他函数
	如果有以下函数
	void f(int);
	void f(int,int);
	void f(double,double = 3.14)
	调用f（5.6）因为第一个参数与double更匹配, 因此调用两个double的函数
	调用f（42, 3.56）第一个参数与int更匹配, 第二个参数与double更比配, 两个函数没有最优, 因此返回二义性错误（ambiguous）
	
=>调用函数重载应该避免强制类型转化, 因为这意味着形参集合不合理

输入输出流函数
	函数可以把输入输出流作为参数或者返回值, 使用引用作为参数或返回值, 例如
	std::ostream &print(std::ostream& , const Sales_data& )
	srd::istream &read (std::istream& , const Sales_data& )
	因为流是不可拷贝的对象, 因此只能是引用

类
this指针
	在一个对象调用成员函数时, 有一个隐藏的this指针, 指向这个对象的地址
	在成员函数用使用变量, 实际上是通过this指针间接完成
	任何定义为this的变量或参数都是非法的, 但是在成员函数内部, 可以直接使用this指针, 虽然并没有必要
=>建议：应该把this视为一个整体来访问对象, 而不应该适用this访问具体的成员

const成员函数
	默认情况下, this指针为非常量指针, 因此不能指向常量, 所以常量对象不能调用普通成员函数
	为了将this指针声明为const指针, 可以在成员函数的声明时, 在参数列表前加上const, 从而将this声明为const, 例如
	std::string isbn() const {return bookNo;}

类的作用域和成员函数
	类本身就是一个作用域, 编译器处理类时, 先处理数据, 再处理函数
	因此在类中, 可以先出现函数, 而不必考虑他们的顺序

在类的外部定义函数
	必须和类中的声明完全一致, 同时定义时, 需要加上类名, 例如
	double Salaes_data::avg_price() const {
		if(units_sold)
			return revenue/units_sold;
		else
			return 0;
	}
	作用域的作用在于告诉编译器, 代码实际上是类的定义, 从而代码作用域属于类, 从而能使用类中的变量

定义返回this对象的函数
	如果需要返回调用成员函数的对象, 可以通过返回this来达到, 例如
	Sales_data& Sales_data::combine(const Sales_data &rhs)
	{
		units_sold += rhs.units_sold;
		revenue += ths.revenue;
		return *this;
	}
	通过对this解引用, 实际上是返回了调用这个函数的对象的引用
=>为什么要返回this：即使不返回this, 也可以达到修改的目的, 但是如果返回了this, 则调用了函数的对象仍然是一个对象, 
		    可以继续调用其它函数或者操作, 例如 myScreen.move(4,0).set('#')
			如果不返回this, 就变成了void
=>注意：只有返回值声明为引用, 才能保证连续调用函数, 否则返回的是*this的副本, 使用引用还避免了拷贝的开销

与类相关的非成员函数
	通常一些辅助的函数, 没有声明在类中, 但是应该声明在同一个头文件中, 以便于用户只需引入一个头文件即可操作

构造函数
	用于对类初始化的函数, 如果没有设置任何初始化函数, 则执行默认初始化, 即
	类中, 已初始化的变量, 用该值初始化, 否则默认初始化, 
	如果类对某种情况定义了初始化函数, 则所以情况都要定义初始化函数
	//construcor
	Sales_data() = default;
	Sales_data(const std::string &s):bookNo(s) { }
	Sales_data(const std::string &s,unsigned n,double p) :
			   bookNo(s),units_sold(n),revenue(p*n) { }
	Sales_data(std::istream &)
	
默认构造函数
	=default的含义
	表示该构造函数为默认构造函数, 可以用在声明和定义中, 在类中定义则隐含内联, 否则默认不内联

构造函数初始值列表
	在另外两个构造函数中, :与{}之间的部分称为构造函数初始值列表, 构造函数初始列表中每个变量使用（）或者{}初始化
	在最后的{}中是构造函数的函数体, 用于执行其他操作, 因为本例中, 只是为了赋值, 因此未空
	在构造函数没有设计的变量仍然使用默认初始化

在类的外部定义构造函数
	与其他构造函数不同, 只有istream的构造函数需要执行一些其他操作来给数据成员赋值
	Sales_data::Sales_data(std::istream &is)
	{
		read(is,*this);
	} 
	构造函数没有返回值, 所以直接从函数名开始, 这个构造函数的构造函数初始值列表为空, 但是通过函数体使类被初始化

使用构造函数
	对象 = 构造函数（参数）;
	因为构造函数总是和类名一样, 所以不需要代码提示, 或者
	类名 = 对象（参数）;
	使用这种方式可以简化声明过程, 如果使用默认构造函数, 即没有参数, 就不要在打括号了
	那样是定义了一个函数


拷贝、复制和析构
	通常编译器会自动完成这些行为, 但是如果动态分配内存, 则可能编译器无法自动完成
	但幸好大部分问题可以使用string和vector解决, 如何自定义见后文

使用struct或者class
	两者除了默认权限不同意外没有区别, struct默认public, 而class默认private
	如果希望类中所有的成员都是public的, 应该使用struct, 反之同理
	
友元
	声明在类外部的函数, 无法访问非public的数据对象, 把这些函数变为类的友元即可访问非public的部分
	注意：作为友元的函数, 除了在类中声明一次, 在外部也要声明
	      应该在类的开头或结尾集中声明所有的友元

类的其他特征
使用别名
	在类中使用的别名与其他成员函数受到同样的限制, 例如在public中定义using pos = std::string::size_type
	则对用户而言, 只能看到pos类型, 而隐藏了使用size_type实现的细节

令成员作为内联函数
	在类的内部和外部都可以显式的使用inline关键字来向编译器推荐内联

重载成员函数
	同其他函数的重载规则一致

可变数据成员
	如果希望在一个const对象中修改某个数据, 可以在类中将其的定义加上mutable关键字, 即使是const, 也可以对其修改

类数据成员的初始化
	在一个类的内部可以包含另外一个类, 对类中的类, 可以使用列表初始化（四种初始化的一种）, 例如
	std::vector<Screen> screens{Screen(24,80,' ')}
	使用构造函数产生一个值, 然后把值赋给包含Screen的vector

从const成员返回*this
	如果成员函数是const, 那么返回的*this也是const, 之后就不能通过该对象修改

基于const的重载
	通过区分成员函数是否是const, 可以进行重载
	创建一个公共部分的const函数, 然后两个版本的函数都调用的这个函数, 例如：
	public：
	Screen &display(std::ostream &os)
					{ do_display(os);return *this;}
	const Screen &display(std::ostream & os) const
					{ do_display(os);return *this;}
	private：
	void do_display(std::ostream &os) const {os << contents; }
	这样不同版本的函数返回的this指针就是不同的版本, 通过两个函数的重载避免const对象不能调用非const的成员函数
	虽然非const对象两个函数都可以调用, 但是非const更匹配

类类型
	类名即类型, 不同类名的类, 即使内部完全一样也不能赋值
	类名只要声明过就可以产生指向该类的指针, 例如定义链表

友元plus
	友元可以定义在类的内部, 从而隐式内联

添加其他类作为友元
	有一个类 Window_mgr有函数需要类Screen的非public数据, 可以使用
	class Screen {
		friend class Windows_mgr;
		...
	};
	从而使Window_mgr的函数可以访问Screen
	注意：
	1.Screen必须以某种方式传入相关的函数, 变成一个对象以后, 才能直接调用其中的非public数据
	2.友元没有传递性, 所以Window_mgr的友元不能直接访问Screen	

添加其他成员函数为友元
	class Screen {
		friend void Windows_mgr::clean;
		...
	};
	必须按照先声明Window_mgr, 在声明Screen中的友元, 最后定义的顺序参数clean函数

友元函数的重载
	重载的函数实际上是不同的函数, 因此如果需要重载, 需要对每个版本进行友元声明, 否则为声明的版本无权限

友元声明和作用域
	实际上除了友元声明意外, 该函数必须在外部声明才能使用, 即使该函数定义在类的内部

类的作用域
	在外部定义的函数, 必须在定义时, 说明属于的类, 之后再函数体和参数列表中, 就可以直接使用类中的对象, 而无须再次声明
	但是函数的返回值类型在函数名的前面, 因此如果函数返回类中的类型, 也需要指明属于哪个类, 例如
	Window_mgr::ScreenIndex
	Window_mgr::addScreen(const Screen &s)
	{ ... }

类型名的特殊处理
	在外部定义过的类型别名, 在类中如果使用过, 则不能再重新定义
	因此, 可以将所有的别名定义放在类的开始, 确保没有任何成员使用过该类型
	
类与头文件
	虽然有头文件保护机制, 但只能确保在一个文件内不会被重复定义, 因此不能在头文件中定义函数和变量
	而且修改头文件不会直接导致从新编译, 所以尽量不要更改头文件
	只有内联函数可以反复定义

构造函数plus
	因为引用后const必须被初始化, 所以在构造函数中必须为其初始化
	所以只能在类中先初始化, 或者使用构造函数, 使用其他函数是赋值, 将被拒绝
	避免用一个成员对另一个成员赋值, 因为赋值的执行顺序和类的定义一致, 因而不一定和期望一致
	对于这种情况, GCC在严格检查条件下, 会给出warning
	
使用默认参数构造函数
	如果一个构造函数为所有的参数都提供了默认参数, 那么这个构造函数也就相当于默认函数
	
委托构造函数
	这是C++11新标准, 一个委托构造函数, 使用类中的其他构造函数来执行初始化过程
	class Sales_data
	{
	public:
		//非委托构造函数使用实参初始化
		Sales_data(std::string s, unsigned cnt, double price):
				bookNo(s),units_sold(cnt),revenue(cnt * proce) { }
		//其余构造函数全部委托给另一个构造函数
		Sales_data() : Sales_data(" ",0,0) { }
		Sales_data(std::string s) : Sales_data(s,0,0) { }
		Sales_data(std::istream &is) : Sales_data() {read(is), *this;}
	};
	注意：最后一个函数也委托给了默认构造函数, 执行完默认构造函数在执行函数体
=>注意：嵌套的结构可能导致不能自动合成默认函数, 因此最后总是能定义默认参数

隐式的类类型转换
	实际上, 只有一个参数的构造函数就是一个隐私的转换规则, 把该参数类型转化为指定的类类型

	但是编译器只会做一步隐式转化, 例如
	string book = "99-999"
	item.combine(book)			//字符串由构造函数转化为一个临时的Sales_data

	item.combine("99-999")			//两步转化, 转化错误
	item.combine(string("99-999"))		//先转化为字符串, 从而变成1的情况
	item.combine(Sales_data("99-999"))	//先转化为Sales_data, 之后与定义的参数类型一致


抑制构造函数定义的隐式转化
	事实上, 并不是任何情况下, 这种隐式的转化规则都是需要的, 可以使用explicit（明确的）关键字加以阻止
	之后, 像上面提到的前几种转化都会报错
=>注意：一旦使用了这个关键字, 在执行构造函数时, 也只能直接初始化了（即只能使用括号, 而不是=）
	但是, 显然上面提到的最后一种, 因为强制调用构造函数, 且为直接初始化, 因此任然有效

标准库中含有的显式构造函数的类
	接受但参数const char *的string构造函数, 不是explicit的
	接受一个容量参数的vector构造函数, 是explicit的

聚合类
	满足一下条件的类, 是聚合类
	1.所有成员都是public
	2.没有定义任何构造函数
	3.没有类内初始值
	4.没有基类, 也没有virtual函数
=>例如C中的struct, 就是一个典型的聚合类
	可以使用一个化括号括起来的成员初始值列表来对聚合类初始化, 但是参数必须与声明顺序一致
	使用这种类有很多缺点, 成员过多的类, 不宜作为聚合类

类的静态成员
	与类直接相关的一些成员, 所有的对象都共用该成员, 只需在定义相关成员的时候加上static关键字
声明静态成员
	同样static的成员函数不与任何对象捆绑在一起, 没有this指针（也就不能调用类中的非static成员）, 
	static的成员函数也不能声明为const（这一点要求this指针为const）
使用静态成员
	非成员函数可以使用作用域符::访问静态成员, 成员函数可以直接访问
	也可以通过对象, 指针, 引用等对其访问
定义静态成员
	规则和一般成员一致, 可以在类中, 也可以在外部定义
	在类中初始化会导致每个对象都包含该static成员, 从而与定义矛盾, 因此必须在外部初始化
	定义的static数据成员与全局变量类似（与C中static变量定义一致）

静态成员的类内初始化
	通常静态成员必须在外部初始化, 但是可以对静态成员提供const整数类型的字面初始值
	这一值可以用来定义数组大小等, 使用constexpr关键字代替const
	但是, 这样定义的成员因为实际上相当于没有定义语句, 因此在某些情况下会导致错误
	所以与其到时候出了错误改的麻烦, 还不如所有的都定义在外部

只有静态成员可以应用的场景
	1.静态成员可以是不完全类型（即该成员是一个类, 但是只提供了类名, 而还没有提供具体内容）
	2.静态成员可以作为默认参数


IO类
一下为对应的头文件和其中包含的流对象
iostream
	istream		从流读取文件
	ostream		向流写入文件
	iostream	读写流
fstream 
	ifstream	从文件读取数据
	ofstream	向文件写入数据
	fstream		读写文件
sstream
	istringstream	从string读取数据
	ostringstream	向string写入数据
	stringstream	读写string

为了支持宽字符语言, 上述的各种流加上w前缀, 即为各种对应的宽字符版本


IO对象无拷贝或赋值
	所以如果函数需要IO对象, 只能引用的传递给函数

条件状态
	一些变量, 用于记录IO操作的状态
	strm代表某种流, 注意所有的流都在名字空间std中	
strm::iostate		一种与机器相关的类型
strm::badbit		指出流已经崩溃
strm::failbit		指出一个IO操作失败了
strm::eofbit		指出到达文件尾
strm::goodbit		指出未出错
	s代表某种流, 函数在对应变量被置位（set）时, 返回true
s.eof()		s.fail()	s.bad()		s.good()

s.clean()		复位所有的状态, 该函数重载版本接受strm::iostate类型参数, 清除指定的状态
s.setstate(flags)	根据给定的flags, 将流中对应的条件状态置位, flags为strm::iostate类型
s.rdstate()		返回流当前的状态, 类型为strm::iostate
注意：这些bit结尾的状态真的都是bit, 所以可以用位操作把多个状态合并到一个strm::iostate变量中
注意：发生错误的那个字符会消失, 所以直接clean就可以了


缓冲区管理
以下情况下, 缓冲区会被刷新
1.程序正常结束, 作为main函数的return的一部分, 缓冲刷新会被执行
2.缓冲区满
3.使用操作符如endl
4.流设置unitbuf, 例如cerr默认是设置unitbuf的, 因此写入cerr的都是立即刷新的
5.一个输出流可以关联另外的流, 例如都cin或者写cerr都会导致cout刷新

显式刷新缓存区
endl(end line)		向缓冲区加入换行, 并刷新缓冲区
flush			只刷新, 不添加任何字符
ends(end space)		向缓冲区加入空字符, 并刷新缓冲区

unitbuf操作符
	名字来自对应的流的空间, 将unitbuf输入到流即可, 例如
	cout << unitbuf;
	同样的方法, 使用nounitbuf, 即可重置流

注意：如果程序崩溃, 缓冲区不会被刷新


关联输入与输出流
	使用tie函数, 该函数是流对象的成员函数, 有两个版本
	不带参数的返回当前关联的流, 无则返回空指针
	使用参数的接受一个一个o对象, 并将两者关联
	可以把一个i对象关联到o对象, 也可以把o对象关联到o对象

文件流
	首先需要包含fstream头文件, 在创建的时候可以直接初始化, 指定文件名, 例如
	ifstream input(argv[1]);	//参数是string, 或者C风格字符串

成员函数
open()		打开一个文件, 与之关联
close()		关闭关联的文件
	可以直接把对象作为条件来判断是否成功打开文件
	一个对象被销毁以后, 会自动关闭关联的文件

文件模式
	通常文件模式, 由指定的文件对象的类型控制, 但是也可以设置一下模式, 这些模式在任何打开文件的时候均可使用
in		以读方式打开
out		以写方式打开
app		每次写操作前定位到文件尾（追加模式）
ate		打开文件后立即定位到文件尾
trunc		截断文件
binary		以二进制进行IO
遵循以下规则：
1.in和out只能在对应的文件对象类型下使用
2.只有设定out时, 才能设定trunc
3.只要没有设定trunc, 就可以设定app. 在app模式下, 即使没有指定out, 也会以out模式打开
4.默认情况下, 即使没有指定trunc, 使用out模式也会截断. 如果需要文件内容, 需要同时指定app, 或者in
5.ate与binary模式可以和任何文件模式组合使用
	组合的方式为适应位运算或（|）, 例如
	ofstream  put（"file", ofstream::out|ofstream::app）
	每次关联新对象时, 可以重新设置模式

string流
	首先需要包含stringstream文件, 相关的操作与iostream一致
	注意, 因为可以先读入字符串, 再使用各种IO操作, 因此便于处理字符串中的多种数据, 例如

	string line, word;
	vector<PersonInfo> people;
	while (getline(cin, line)) {
		PersonInfo info;
		std::istringstream record(line);
		record >> info.name;
		while (record >> word)
			info.phones.push_back(word);
		people.push_back(info);
	}
	同理, 在构造格式化的输出时, 也可以类似的使用ostringstream


顺序容器
vector		可变大小的数组, 在尾部以外的地方插入数据可能很慢
deque		双端队列, 支持快速随机访问, 两端插入和删除速度快
list		双向链表
forward_list	高性能的单项链表
array		固定大小的数组
注意：以上所有的都是模板, 使用时需要先包含对应的头文件
	  各个模板的实现方式与数据结构中所学类似, 按照需要选择即可

注意以下的技巧
如果只是在读取的时候, 需要在中间插入元素, 之后需要顺序访问, 可以
1.使用vector追加元素, 然后调用sort（）函数来排序
2.在输入阶段使用list, 输入完成后拷贝到vector
如果既需要随机访问, 又需要再中间插入数据, 则需要综合考虑访问和插入的比例
=>如果不确定, 可以只使用所有容器的公共操作, 不使用下标和随机访问, 然后再必要的时候, 可以方便的改变容器结构


容器操作

构造函数	
C c			默认初始化
C c1(c2)		构造c2的拷贝c1
C c(b,e)		将迭代器b, e指定范围的元素拷贝到c（不要求容器和元素类型相同, 可以转换即可）
C c{a,b,c,d}		列表初始化c

赋值与swap
c1=c2
c1={a,b,c,...}
a.swap(b)
swap（a, b）		函数来自std, 与a.swap(b)相同
c.assign()		对c重新赋值, 可重载, 参数与构造函数相同

=>赋值操作会导致容器内部的迭代器, 引用, 指针失效, 
=>除array以外, swap保证不对任何元素进行拷贝, 只是交换容器的内部结构, 从而保证在常数时间内完成
=>除了string意外的容器的迭代器仍然有效, 但是已经指向不同的元素了

大小
c.size()		c中元素个数(不支持forward_list)
c.max_size()		c中可保存的最大元素个数（实测>1亿）
c.empty()		判断c是否为空

添加与删除元素（不适应与array）
在不同容器中, 一下操作的接口均不同
c.insert(args)		将args中的元素拷贝到c
c.emplace（inits）	使用inits构造c中的一个元素
c.erase(args)		删除args指定的元素
c.clean()		删除c中的所有元素, 返回void


关系运算符
==, ！=			所有容器都支持
<,<=,>,>=		无序关联容器不支持

获取迭代器
c.begin(),c.end()	指向c的迭代器
c.cbegin(),c.cend()	常量版本

反向容器的额外成员
c.rbegin(),c.rend()	指向c的反向迭代器
c.crbegin(),c.crend()	常量版本

注意：标准库提供上述的相关函数, 可以用于获得内置数组的迭代器, 名字来自std

标准库array
定义时, 除了指定元素类型, 还要指定大小, 和内置的数组相比, array的优势是可以看作一个整体, 从而可以相互赋值

使用emplace操作
	有三个函数emplace_front,emplace,emplace_back,接受构造函数的参数, 从而构造一个值插入在指定的位置

访问元素
注意：需要先检查容器是否为空（使用empty函数）
c.back()	返回c中尾元素的引用
c.front()	返回c中首元素的引用
c[n]		返回下标为n的元素的引用
c.at(n)		返回下标为n的元素的引用, 越界会抛出异常out_of_range

特殊的forward_list操作
	因为在链表中删除一个元素, 需要该元素之前的元素的变化, 单项链表中, 很难简便的获得前一个元素
	因此相关函数, 均为给出前一个元素, 另外提供一个begore_begin()成员函数, 返回所有元素之前的一个位置

不要保存end返回的迭代器
	因为但凡更改容器, 该迭代器几乎都会失效, 因此每次使用时, 都应该重新计算, 而且STL对其实行是非常快速的

容器大小管理
c.shrink_to_fit()	将capacity()减小到与size()同样大
c.capacity()		不重新分配内存, c可以保留的元素个数
c.reserve(n)		分配至少可以容纳n个元素的内存空间


容器适配器
	标准库中定义的三种容器适配器, stack, queue, priority_queue
	一个容器适配器, 接受一个已有的容器类型, 使其行为看起来像是一种不同的类型
支持的操作
A a		创建一个空适配器
A a(c)		创建一个带有c内容拷贝的适配器
a.empty()	
a.size()
a.swap(b)

创建
stack<int> stk(deq)		//假设deq是一个deque<int>
stack<string,vector<string>>	//创建一个基于vector的stack

所有的都可以基于deque来构造, 其他的看情况匹配

stack操作
定义在stack头文件中
pop()
push(item)
emplace(args)
top()

queue和priority_queue操作
都定义在queue中
pop()			弹出第一个或者最优先的元素
front()			
back()
top()
push()
emplace(args)


泛型算法
	大部分算法都定义在algorithm中. 在头文件numeric中定义了一组数值泛型算法,P336
	更多相关内容, 参见C++ Primer 的附录A

更多与容器相关的内容以及算法, 略过, 待以后能使用时再补充


动态内存与智能指针
	标准库定义了三种指针, 分别是shared_ptr,unique_ptr,weak_ptr, 三个都是模板, 使用类似vector
	三个都来自头文件memory中

两个指针都支持的操作
	除了普通指针支持的操作以外, 还有一个get（）成员函数, 用于返回保存的指针的值, 如果智能指针释放了指向的对象
	那么返回的指针指向的值也就无效了
	swap操作与容器一致

shared_ptr独有的操作
	相关的初始化, 赋值等操作, 有两个成员函数use_count()返回共享的指针指针数量, 可能很慢, 主要用于调试
	unique（）如果use_count()为1, 则返回true, 否则false

make_share函数
	标准库提供的函数, 所以需要加上std::前缀, 动态的分配一段内存, 例如
	shared_ptr<int> p = std::make_shared<int>(32);   //分配一个值为32的int的空间

	shared_ptr<string> spt = std::make_shared<string>(10,"9");  //指向"999999999", 实际上就是string的构造函数
	简言之, 参数必须能匹配某一个构造函数, 如果不传递参数, 就会进行值初始化

直接管理内存
	使用new运算符莱分配内存, 使用delete来释放new申请的空间, 例如
	//new后面直接加类型, 分配一个类型的空间, 默认初始化
	int * p = new int
	//后面加上圆括号, 进行初始化, 用法与make_shared一致
	int *p = new int(1024)	
	//值初始化
	int *p = new string()
	int *p = new int()

自动推断
	auto p1 = new auto(obj)
	p1是指针, 根据obj的类型判断, 例如obj为int, 则p1为int *, 括号中只能是单一对象

动态分配的const对象
	const int *pci = new const int(1024);

内存分配失败
	new抛出bad_alloc异常, 如果不希望new抛出异常, 可以加上nothrow, 例如
	int p = new (nothrow) int;
	那么new返回一个空指针；bad_alloc和nothrow定义在new头文件中
	
delete
	后面加上指针, 即可释放指针指向的对象, 但是编译器不检查一个对象是否已经被释放
	释放已经被释放的指针, 会导致错误, 但是空指针总是可以被释放

share_ptr与new结合
	shared_ptr<int> p1(new int(42));   //p1指向值为42的int
	这个构造函数是explicit的, 所以不能把一个内置指针隐式的转化为智能指针, 只能直接初始化

两条建议
	1.不要混用智能指针和普通指针
	2.不要用get（）对其他智能指针赋值（本质还是不要混用两种指针）

使用自己的释放操作
	在创建share_ptr的时候, 有一个可选的参数可以定义自己的释放操作, 这样在释放的时候
	不再是执行delete, 而是给定的函数
	void f(int * p)				//先定义执行释放操作的函数
	shared_ptr<int> pi(new int(20), f);	//把这个函数传递给shared_ptr

unique_ptr
相关操作
u = nullptr	释放空间, 将u置空
release（）	放弃管理权, 返回指针, 并将自己置空
reset（）	释放空间, 并置空
reset（q）	提供参数则重新指向q
具体用途暂时不明, 待后续补充

weak_ptr
	可以指向一个share_ptr, 但是此操作不会使计数器增加, 对象是否销毁也与weak_ptr无关

相关操作
lock（）	检查所指对象是否存在, 如果存在返回share_ptr,可以使用这样的语句来判断
		if (auto p2 = p.lock ())  如果不存在, 跳过if语句

拷贝构造函数
	在任何非应用的传递和非直接初始化的过程, 都是使用的拷贝构造
	默认的拷贝构造是对对象的每一个类调用他们自己的拷贝构造函数, 基本的数据结构直接拷贝

拷贝构造函数的参数必须是引用
	因为如果不是引用的化, 在实参传递过程中需要拷贝, 从而导致循环

重载操作符=
	只是改变了使用=时的行为, 其他的非引用过程还是由拷贝构造函数控制
注意：一般返回指向左边变量的引用, 因为参数是引用, 为了能连等, 所以也应该返回引用

析构函数
	用于在对象销毁时, 释放其使用的空间

三五原则
	如果需要析构函数, 那么必定需要拷贝构造函数
	如果需要拷贝构造函数, 那么多半也需要重载=

使用=default
	显示的向编译器表面需要合成默认的构造函数, 拷贝构造函数, 析构函数

定义删除函数
	在函数声明的后面加上=delete, 表面不需要这个函数, 从而达到阻止拷贝等目的

重载运输符
	因为本质上是重载, 所以不需要和类定义在一起, 如果作为成员函数定义, 那么调用这个的对象的this会绑定在运算符的左边
	这样就会少一个参数

直接调用
	这些定义的函数是可以直接调用的, 和在表达式中使用是完全相同的

某些运算符不应该重载
	逻辑运算符与逗号运算符, 因为无法保证求值的顺序和短路特性, 因此不建议重载

重载输出运算符
	通常第一个参数是非常量应用的ostream, 第二个参数是常量的对象引用, 从而保证最大程度的适应
	应该尽量减少格式化, 从而给用户留有余地

std::initialize_list<string>
	用来表示列表初始化中的列表的类型, 从而可以重载
	列表初始化的=

重载=的要点
	先释放自己的空间, 然后创建空间使用, 注意先判断是不是指向同一个目标

重载++
	分为前置和后置, 前置的和其他的运算符相同, 后置的使用一个int形参, 这个形参因为不使用, 所以不需要名字
	T operator++(int)	后置
	T operator++()		前置

重载函数调用运算符
	这样的类就相当于一个函数, 但是可以储存信息, 因而比函数更加灵活, 例如
struct absInt {
	int operator()(int val) const {
		return var < 0 ? -val : val;
	}
}
	由这个类创建的对象就都是可调用的了, 实际上也就是执行上面的这一段代码

类型转化运算符
	operator type() const;
	type为任何的函数可以返回的类型, 除了void, 该操作定义了从类类型转化为type指定的类型的方法

转化次数
	这个转化是与基本类型转化独立的, 因此在这种情况下, 相当于可以转化两次

显示的类型转化运算符
	即在定义处加上expliccit关键字, 这样就必须使用static_cast才能转化, 直接使用会被拒绝

为什么while循环中, 可以直接用cin作为条件
	因为操作完成后会返回流, 同时IO库中的流都定义了转化为bool的转化运算符, 如果流是good, 返回true

避免二义性转化
	最常见的情况是A中定义了, 从B到A的转化, B中也定义了, 第二个是所用的参数本身可以转化
	第二个常见于基本的算数类型

类型转化与函数重载
	如果有太多类型转化, 同时又有很多不同类型参数的函数重载, 那么就会十分的麻烦

函数比配与重载运输符
	重载的调用符也是函数, 也是按照参数匹配的, 所以这三个混在一起就更蛋疼了. . 

C++面向对象编程
定义派生类
	在派生类的名称后面输入冒号, 后面是基类的名称

虚函数
	表示基类希望派生类重写的函数, 如果基类不重写, 该虚函数也可以使用
注意：不是虚函数也可以重写, 但是按照虚函数的定义, 这样的函数, 应该定义为虚函数

派生类向基类转换
	使用基类的地方都可以使用派生类, 但是只能使用基类已有的方法, 如果派生类对该方法进行了重写, 那么调用派生类的方法
	概括来说, 就是动态绑定

派生类的构造函数
	在派生类的构造函数中, 直接调用基类的构造函数来对继承的基类成员赋值

更深入的理解类
	类进行的访问控制, 是对所有其他的部分都是成立的, 所以在派生类中使用的基类也是不能访问private的
	所以在类的设计中, 也应该设计充分的接口, 在派生类的编写中, 只使用这些接口

类中的静态成员
	无论基础体系是怎样的, 这些静态成员只有一份, 不管是基类还是派生类, 都可以修改这些成员

防止继承
	在class中的名称后面加上final关键字, 表示该类, 不能作为基类

类型转化与继承
	可以将派生类的对象或地址赋值给基类的引用或者指针

静态类型与动态类型
	在代码中声明的类型, 是在编译时就已经知道的, 是静态类型
	但是一个类的具体类型取决于运行时绑定的对象, 这样动态类型与静态类型就不一致了
注意：只有引用或者指针会这样, 其他类型的静态类型必定与动态类型一致

为什么派生类可以转化为基类
	因为基类的指针可以绑定在派生类的基类部分上, 所以从而可以使用指针使用相应的对象

关于继承过程的内存实现的推测
	也许基类的成员是连续分布的, 派生类的成员在后面, 但是重写的函数会替换原来的位置的函数指针
	所以如果指针指向首地址, 基类和派生类看起来是一致的, 而且调用函数会动态的绑定到基类上
	而且因为是指针的传递, 没有空间的问题, 所以可以这样不一样, 而实体就不能这样了
	（Java总是引用, 那么所有地方就都可以这样向上造型了）

虚函数
	在C++中, 无论是否使用一个虚函数, 都必须为其提供定义, 重写的函数会自动视为虚函数
	如果使用指针或者引用调用虚函数中, 因为派生类可以向基类转化, 所以编译器无法在编译器确定是哪一个版本
	在派生类中重写虚函数的时候, 应该和原来的参数列表以及返回类型一致, 如果不一致, 会视为定义了一个其他函数
override
	可以在声明的时候const的后面加上override（推翻）, 这样编译器会检查该函数是否覆盖了一个虚函数
	无论是没有覆盖虚函数, 或者是该函数不是虚函数, 编译器都会报错
final	
	如果在函数定义的时候在override相同的位置使用final关键字, 编译器会检查该函数不被任何函数覆盖

虚函数和默认参数
	调用函数的时候, 使用的参数是静态类型的参数, 所以最好派生类和基类默认参数一致

回避虚函数机制
	使用作用域符::,来强制指明调用的版本, 从而回避虚函数机制
	当重写的虚函数, 需要调用基类的虚函数时, 就可以使用这样的控制, 从而避免传入派生类对象, 导致无限递归循环

纯虚函数
	只有当前结点, 可以访问基类的depublic成员的时候, 才能进行转化

改变个别成员的可访问型
	在不同的访问控制符作用域下使用using接上需要的成员名称, 即可改变相关成员的访问权限

默认的继承保护
	对于class定义的类, 默认private继承, struct定义的类, 默认public继承

类的名称查找与函数重载
	名称查找大于函数重载, 所以如果派生类中与基类有同样的名称的函数, 则基类的会被覆盖, 即使它们的参数列表不同
	如果原来的函数中有一些重载函数, 那么在派生类中只要定义了一个函数, 就会把所有的重载函数都覆盖
解决方案
	在派生类中使用using, 这样所有的重载函数, 都变为可见, 然后覆盖一部分需要的即可

虚析构函数
	通常需要定义一个虚析构函数, 用于动态的释放特定的资源

容器和继承
	容器中不能存放不同类型的对象, 也不能把派生类放入基类的容器中, 这样会变成阉割版, 只包含基类中的元素
解决方案
	在容器中存放指针, 这样就可以保证继承的关系, 也可以存放在容器中, 而且使用智能指针更好
	（Java中各种new, 就是这种方案吧）


C++模板
	使用template关键字开头, 之后紧跟一对尖括号, 其中使用typename定义需要的模板类型, 例如template<typename T>, 声明多个类型时, 中间使用逗号分开, 但是每个类型前面都必须要有typename关键字
	无论是定义模板函数还是定义模板类, 都是使用typename关键字, 在古老的代码中, 也有使用class关键字的, 在此处class关键字和typename关键字意义相同
	在模板类的外部定义函数是, 首先要加上表示模板的前缀, 即template<typename T>

模板实例化
	一个模板中的函数和变量, 只有在使用到的时候, 才会被实例化

模板类中简化模板类名的使用
	在定义模板类的时候, 如果在该模板自己的作用域中, 可以省略参数类型, 默认为生命的T类型

类






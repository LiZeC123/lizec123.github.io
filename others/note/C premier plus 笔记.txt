C premier plus 笔记

变量命名
	c库通常使用一个或者两个下划线开始的宏, 因此在给变量命名时, 应避开这种命名方式. 
	c语言区分大小写, 注意不要打错. 
	c语言变量应选取有意义的名称或者增加注释. 

数据类型
	数据类型的取值范围受计算机位数的影响. 通常有一位来表示符号, 故对32位下的int而言, 取值范围为2^15-1到 -2^15. 

数值范围问题
long short unsigned是数据类型的前缀
同时long int 也简称long
故还有long long类型
unsigned对所有的类型有效需要c99

数值储存与打印
在数据末尾加上一个L, 则该数据会被强制以long存储
在数据末尾加上两个L, 即LL, 则该数据以long long 存储 加上LLU, 则以unsigned long long存储. 
当数据是浮点型时(即数据包含了小数部分)那么加上后缀F,则数据强制以float存储, 加上后缀L, 则数据强制以long double存储. 
在数据输出中%ld输出long型数据, 其中的l代表long, 该符号可与表示八进制与十六进制的符号结合用于输出相应的数据类型. 
在数据输出中%hd输出short型数据, 其中的h代表short, 该符号可与表示八进制与十六进制的符号结合用于输出相应的数据类型. 
在数据输出中%u输出 unsigned int, %lu输出unsinged long, %lld与%llu意思同理. 

char型数据
在c中, 1byte定义为char所占的bit数, 在c的有关文档中有可能会有提及. 

转义字符
使用 \\  和 \` 和 \" 来使用 \ 和 ` 和 "
使用`\007`, 即在单引号下加入反斜杠和ASCII的八进制数值即可对应相关的字符, 十六进制下同理. 这样可以解决一些转义字符编译器无法识别的问题. 

limits.h头文件中可以查看有关取值的信息

inttypes.h中包含一些数据类型的别名, 可能提供最快或者最大的数据类型. 

浮点数据的输入
例如
4.25e-12
其中e代表后面表示指数, 可以在需要的时候省略小数部分或者整数部分. (但是在e的前面必须要有什么, 小数部分或整数部分)
在十六进制下表示 . 例如
0xa.f1p10
p代替十进制中的e


下面是各种数据类型的输出占位符：
short/int : %d
long: %ld; 
	long 是int的修饰
long long: %lld
	对于dev c++ 是%I64d 
unsinged long long:%llu
	对于dev c++ 是%I64u
char : %c
float : %f 
double :%lf
	double也就是long float;
char *s(字符串) ：%s
unsigned: %u  
输出8进制用%o 如果加前缀 用%#o
输出16进制用%x 如果加前缀 用%#x
地址值/指针值：%p
以科学记数法输出:%e
sizeof的提示符通常是%u
	c99中提供了%zd
%%
	打印一个%
	如果错误的使用其他占位符, 则会截取高数位的部分数据. 

printf()的转化说明修饰符
	转化修饰符是加入在%和定义转字符之间用于对转化类型加以修饰. 
digit(s)
	字段宽度最小值, 如果数据长度不足, 会用空格补充
	如%4d
.digit(s)
	精度, 对于浮点型是小数数位, 对于整	数型是数位, 对于字符串是打印字符最大数目, 对于%g是有效数位的最大值, 只有一个.等同于.0
	例如
	%4.2f 表示flout型数据显示至少4位, 跟随两位小数. 注意, 前面的4是指包括整数部分, 小数部分的长度
标志
-
	左对齐
+
	强制增加符号
(空格)
	前导空格, 用于填充字段宽度如果同时有+, 则该标志会被覆盖
#
	在十六进制或者八进制中输出中显示前缀
0
	用0代替空格填充字段宽度
*
	滞后赋值, 即在上述以及下面的digit部分, 如果需要在程序运行时再决定大小, 则可以使用该符号, 其与其他占位	符一样由后面的变量赋值

	因为printf()的实现与堆栈有关, 所以如果在多个参数中有一个错误的占位符, 可能导致接下来的数据也是错误的. 


scanf()的转换修饰符(p79)
*
	跳过对应位置输入的值
digit
	最大字段宽度, 达到最大字段宽度或者	遇到第一个空白后停止输入

	scanf()的占位符与printf()的占位符基本相同, 只是对于double型用%lf, 而printf()用%f

scanf()的返回值
	scanf()返回成功读入的与提示符相对应数据的个数, 如果scanf()读入数据与提示符不同, 则该数据仍放在缓冲区, 如果在循环中无条件的执行scanf(), 那么因为总是读入失败而导致死循环

printf()的返回值
	printf()返回成功打印的字符个数


变长数组初始化在0xffffffff(32位)
如果对变成数组的变量附一个适当的值, 那么变长数组的位置会改变到一个合适的位置
如果对变长数组的变量赋值失败, 又恰好有一个巨大的数值, 这将导致试图覆盖不属于程序的内存段, 而导致错误. 

转义字符的一个例子
\b
使光标向前移动一格, 但不会删除原来的字符, 因而可以先输入下划线在输入退格来提示用户输入. 

字符串与格式化输入输出
	在字符串结束的地方会有一个\0表示字符串结束, 故容纳字符串的空间必须比给定的字符数大1. 
	字符串可以作为宏, 并以%s输出. 
	scanf()会在字符串中遇到的第一个空格, tab, 换行符后结束

strlen()函数
属于头文件string.h
以字符为单位给出字符串(字符数组)的长度, 不包括字符串末尾的结束符号. 

常量
方法一 使用宏
方法二 const修饰符
	在变量声明前面加入const即可将该变量变为常量. 

宏
在limit.h和float.h中包含例如INT_MAX等表示有关数据类型的大小限制. 
宏名基本上命名方式相同

c语言可以连续赋值
如 a=b=c=1是合法的语句

取余
在任何情况下 a%b=a-(a/b)*b来计算

++和--运算的一个明智做法
	把变量增加和变量赋值写在两排, 这样++无论是前缀还是后缀都不影响结果
	如果一个变量出现在一个函数的多个参数中时, 不要将增量或者减量运算符用于它上面
	当一个变量多次出现在一个表达式里时, 不要将增量或减量运算符用到他的上面
	因为c语言不保证此时的运算顺序

副作用和顺序点
	赋值语句中的对变量赋值是其副作用, 主要目的是计算值
	顺序点是程序执行中的一点, 在该点处所有的副作用都会在进入下一步前被计算, 分号是顺序点



运算优先级
一共有十五个优先级： 
1   ()  []  .  ->
2   !  ~   -（负号） ++  --   &（取变量地址）*   （type）(强制类型)    sizeof 
3   * / %
4   + - 
5   >> <<  
6   > >= < <= 
7   == !=   
8   &  
9   ^   
10  |   
11  &&
12  ||
13  ?:
14   =  +=  -=  *=  /=   %=  |=   ^=   &=   >>=   <<=
15  ,


while语句
while (expression)
	statement
当expression的值非零时, 执行statement



关系运算符的一个要点
在浮点数比较中, 应避免使用大于等于或者小于等于, 因为舍入误差可能导致两个逻辑上相等的数不相等

<stdbool.h>
包含该头文件后, 可以使用bool来定义布尔变量, 把ture定义为1, false定义为0, 这样写出来的代码可以与c++兼容. 

for语句和逗号运算符
	for的三个条件可以放入任何语句, 只要能保证循环的正常进行. 
	逗号运算符可以使for在对多个变量进行初始化, 即起分隔作用. 
	除此以外, 逗号还具有作为顺序点的功能, 即保证所有在逗号左边的副作用在逗号的右边之前结束

do while语句
	do while语句在最后需要分号

数组
	出于执行效率的考虑, C不检查是否使用了正确的下标, 即, 不对数组边界检查

getchar()与putchar()
	getchar()没有参数, 它返回来自输入设备的下一个字符
	putchar()有一个char参数, 它会打印该参数
	两个函数只处理字符, 因此比通用的输入输出函数快且简洁, 而且它们通常只是编译预处理宏, 而不是真正的函数

宏 SPACE
	需要使用空格时, 最好定义一个叫做SPACE的宏, 而不是' '


ctype.h
	该头文件中包含各种关于字符判断的函数, 可以便捷的判断输入字符的类型

if与else的配对
	默认在没有花括号的情况下, else与最近的if配对

条件运算符？:
expression1？expression2:expression3
如果expression1为真
	整个表达式值为expression2
如果expression1为假
	整个表达式值为expression3
max=(a>b)？a:b;
特点 
	因为这样比if-else语句简单, 故可以把这个语句嵌套在其他语句的内部

switch语句

switch(integer expression)
{
	case constant1：
                      statements
	case constant2:
                      statements
	default:
                      statements
}
如果不配合break 那么对应执行的语句下面的每一句都会被执行
switch的条件必须是一个整数型变量, 包括char型, case的标签必须是整形常量, 包过整数常量表达式
可以给一个语句多个标签, 即把多个case放在一起, 只在最后的一个case中写语句和break
注意, default语句是可选的

goto语句
goto label
label: statement
goto可以用于从多层嵌套中直接跳出来
其他情况下, 应避免使用
	
缓冲区
	缓冲分为完全缓冲I/O和行缓冲I/O, 		
	完全缓冲当缓冲区满时被清空, 缓冲区大小取决于系统, 但一般为512或4096字节. 
	行缓冲当遇到换行字符时清空缓冲区. 

conio.h头文件
	其中包括了专门用于非缓冲输入的函数系列

流
	输入输出设备作为每个c程序自动打开的文件来对待, 键盘输入流为stdin, 到屏幕等的输出流为stdout

EOF（End Of File）
	#define EOF= （-1）
	c不考虑系统如何判断文件是否到达末尾, 当文件到达末尾时, getchar()返回EOF, 通常这个宏被定义在stdio.h中

解决缓冲区中多余字符的方案
while(getchar()!='y')
{
	printf("   ");
	while(getchar()!='\n')
		continue;
}
可以跳过每行除了第一个字符以外的其他所有字符

函数留名
在return后面的语句永远不会被执行
printf("Professor Fleppard is like totally a fopdoodle.\n");

声明指针
	*和指针名之间的空格是可选的, 通常在声明中使用空格, 在指向变量的时候将其省略

只读数组
	在数组声明前面加入关键字 const 则该数组变为只读数组, 只能在定义的时候进行初始化

数组初始化
	在对数组进行部分初始化后, 其余未被初始化的元素会被初始化为0, 如果省略数组括号内的数字, 那么编译器会进行自动匹配

数组循环处理的一个细节
	使用for循环时, 让数组下标从零开始, 用sizeof（a）/sizeof（a［0］）来计算数组大小(针对使用花括号初始化的数组), 从而避免人工计数导致的错误. 
	但是, 当初始化元素个数有误时, 这种自动计数会导致该错误难以意识到. 
	或者在声明数组时使用常量, 之后在任何地方使用数组大小时都直接引用该常量

指定初始化项目
int arr［6］={[4]=212, 5};
结果为
arr[4]=212, arr[5]=5

初始化二维数组
	二维数组的每个元素都是一个数组, 所以每个元素安装数组初始化的方式进行初始化

指针与数组的关系
	ar［i］与 *(ar+i)相同, 在使用时可以按照方便程度使用
	在函数声明时, 可以用int *ar 
代替 int ar［］, 而且也只有这种情况下可以代替, 但是使用数组形式可以提醒读者这是一个数组, 而不仅仅是一个指针
	在函数声明时, 可以使用省略参数名称, 使用如下的形式
 int sum (int *, int);
int sum (int［］, int);

指针运算补充
	当两个指针相减时, 返回两个指针对应数据的大小的个数, 而不是地址差值的绝对值
注意 一定不要对还未赋值的指针写入数据, 该操作有极大的风险

保护数组内容
	因为函数调用数组是传递的是指针, 所以有时候不想让数组被改变是, 应该对其进行保护
	在函数声明中加入const, 即可使编译器检查函数是否对该数组进行了修改, 例如
int(const int ar［］, int n);

const的其他用法
	可以用于创建, 指针常量, 以及指向常量的指针
	指针常量(例如 int * const p)可以保证该指针不会在指向其他地址, 但和声明常量一样, 必须在声明的时候赋值
	指向常量的指针(例如 const int * p)可以保证不能通过该指针修改其指向的数值, 在函数中使用该声明来表示函数不通过该指针修改数据, 只有常量或者非常量数据的地址可以赋值给指向常量的指针
	完全不变的指针(例如 const int * const p)可以保证指针不会指向其他地址, 同时也不能通过该指针修改数据

指针与多维数组
	在多维数组中, 多维数组可以看成数组的数组, 以ar［4］［2］为例, ar=&ar［0］, 同时&ar［0］本身也是一个数组, 所以ar［0］=&ar［0］［0］
	对ar+1, 则指向ar［1］即ar［1］［0］, 同理对ar［0］［0］+1, 则指向ar［0］［1］
	因此 ar［0］［0］=*ar［0］=**ar, 

指向多维数组的指针
	int (*p) ［2］
	此语句表明p是指向包含两个int值的数组的指针
	int *  p［2］
	词语句将创建两个指向int值的指针构成的数组


sizeof运算符
	sizeof用于char的字面量时, 因为数据对齐, 会返回4, 计算结构体时, 也会因为对齐而导致一定程度的变大, 
	计算数组时, 返回数组的实际内存的空间


定义字符串
一  字符串常量
	指位于一对双引号之间的任何字符, 双引号里的字符加上编译器自动提供的结束字符\0, 作为一个字符串被储存在内存里, 作为printf()或者puts()的参数, 此类字符串也可以用#define来定义
	两个没有间隔或者间隔为空格的字符串会被自动连接起来, 字符串中转义字符仍然使用
	字符串常量属于静态储存类, 即多次调用使用此字符串的函数时, 该字符串在运行过程中只储存一份, 整个引号中的内容, 作为指向该字符串储存位置的指针, 因而可以将其赋值给一个char指针, 这一点与把数组名作为指向数组储存位置的指针类似

二 字符串数组及其初始化
	如果使用字符串常量进行初始化, 则不用加\0, 如果使用单个的字符对数组元素逐一初始化, 则必须加上\0, 否则得到的只是一个字符数组而不是字符串, 数组中剩下的未被初始化的元素会被自动初始化为\0
	编译器可以自动匹配数组元素个数

三 字符串数组
	即声明一个指针数组, 其中的每一个元素都是一个指向某一个字符串的指针, 由于指针和数组的关系, 可以把该指针数组看成一个二维数组, 从而使用字符串中的某一个字符
	当然也可以直接用二维数组来储存字符串, 区别是使用指针数组相当于一个不规则的二维数组, 从而不会浪费内存空间

数组和指针
	无论以数组形式还是以指针形式声明, 都会在内存中获得一份空间, 但是数组名会被处理为一个常量, 因而不能使用如++这样针对变量的运算符, 而指针则不受影响
	不能用指针对字符串常量的值进行修改, 因为编译器会把程序中所有的该字符串使用同一地址, 对其修改后, 会导致程序其他地方的引用出错, 然而这一点并不是所有编译器都会阻止, 因此推荐的用法是初始化一个指向字符串常量的指针时使用const修饰符, 如const char *p="example"

gets()函数
	函数原型 char *gets(char * s)
	gets()函数从输入设备读入一些以/n结尾字符, 去除/n后加上\0, 并将该字符串存入s中, 并返回指向该字符串的指针, 注意, 实际上返回的指针就是作为函数参数输入的指针, 如果读取失败或者遇到文件尾, 则返回NULL
	注意, gets()函数不检查s能否存放输入的字符, 因此容易导致溢出的问题, 因此该函数应该避免使用

fgets()函数
	fgets()函数有三个参数, 第一个是存放字符串的地址,
	第二个是最大读入字符数, 如果参数为n, 则读取最多n-1个字符, 然后再末尾加上\0,或者在之前遇到\n, 同时\n也会被读入到字符串中
	第三个是读取的文件, 从键盘读入数据时可以使用stdin
	到达文件末尾, 不返回EOF, 需要使用feof（）函数判断

feof（）函数
	参数是文件指针, 如果该指针到达文件末尾, 则返回0, 否则返回非0值, 使用该函数判定结束, 会导致目标文件比源文件略大
	

puts()函数
	puts()函数的参数是字符串参数的地址, 地址可以是起始位置, 也可以是字符串中间的某一个位置, puts()函数会一直输出到遇到空字符, 即\0, 并在输出结束后自动加上\n

fputs()函数
	fputs()函数第一个参数是字符串的地址
	第二个参数说明要写的文件, 如果只是输出可以使用stdout

字符串函数
strlen()函数
	返回字符串的长度, 不包括最后的\0

strcat()函数(string concatenation)
	接受两个字符串参数, 它把第二个字符串的一份拷贝添加到第一个字符串的结尾, 并返回指向这个字符串的指针, 即第一个参数
strncat()函数
	与strcat()函数相比, 需要第三个参数, 来说明允许添加的最大字符数, 例如参数为n, 那么或者先遇到\0而结束, 或者复制n个字符后加上\0结束, 因此被添加的字符串应至少还有n+1个字符的空间

strcmp()函数(string comparison)
	strcmp()函数接受两个指针, 并比较两者的内容(content)是否相同
	如果相同, 则返回0, 如果第一个字符在机器编码中的顺序先于第二个字符则返回一个负数, 反之则返回一个正数, 具体数值依赖于不同的是c实现, 如果字符串前面的几个字符相同, 则返回第一个不同的字符对应的返回值
	注意, 返回0在逻辑中与相当于假, 注意区分
strncmp()函数
	与strcmp()函数相比, 需要第三个参数n来指定比较的两个字符串的前n个字符是否相同

strcpy()函数
	接受两个字符串, 将第二个字符串(source)的值复制到第一个字符串(target), 和赋值语句相同, 目标字符串在左边
	strcpy()函数返回第一个参数的值, 同时, 第一个参数不需要指向数组的开始, 这样可以保证数组只有一部分被覆盖
strncpy()函数
	与strcpy()函数相比, 需要第三个参数n来说明最大可复制字符数
	注意, 如果n恰好与strlen(source)相同, 那么末尾是没有\0字符的, 因此最后使n比target最大容量小一, 然后手动添加\0字符

sprintf()函数
	与printf()相比, 除了第一个参数指定字符串位置以外, 其余参数与printf()相同, sprintf()函数将后面参数指定的内容写入第一个参数指定的位置

其他字符串函数
char *strchr(const char * s1,int c);
	返回字符串s1中字符c第一个位子的指针, 如果没有出现, 则返回NULL
char *strpbrk(const char * s1,const char * s2);
	返回s1中第一次出现s2中任意字符的位置的指针, 如果没有出现, 则返回NULL
char *strrchr(const char * s, int c);
	返回字符c在s中最后一次出现的位置的指针, 如果没有出现, 则返回NULL
char *strstr(const char * s1, const char * s2);
	返回s1中s2第一次出现的位置的指针, 如果没有出现, 则返回NULL

命令行参数
	main函数有一个int参数 argc(argument count)和一个char指针数组argv(argument value)
	以命令行形式输入的参数会安装空格分成几个字符串存储在argv［］中, argc记录有多少个参数被输入, 在很多系统中允许使用引号把多个单词集中在一个参数里, 另外argv［0］存储程序本身的名字

把字符串转化为数字
atoi()函数
	读入一个字符串, 把其转化为一个int返回
atof()函数
	读入一个字符串, 把其转化为一个double返回
atol()函数
	读入一个字符串, 把其转化为一个long返回
上述函数包含在stdlib.h中


作用域和链接
外部链接
	一个具有外部连接的变量可以在多文件程序的任何地方使用
内部链接
	一个具有内部连接的变量可以在一个文件的任何地方使用, 内部链接需要在声明前面加入static关键字

存储时期
静态存储时期(static storage duration)
	如果一个变量具有静态存储时期, 那么它在程序执行期间将一直存在, 具有文件作用域的变量具有静态存储时期
自动存储时期(automatic storage duration)
	具有代码块作用域的变量一般情况下具有自动存储时期, 该程序进入定义这些变量的代码块时, 将为这些变量分配内存, 当退出这个代码开始, 分配的内存将被释放

一 自动变量
	具有自动存储时期, 代码块作用域, 空链接, 通常情况下, 在代码块或函数头部定义的任意变量都属于自动存储类, 也可以在定义语句前加入auto关键字来强调这一点

二 寄存器变量
	如果足够幸运, 使用register关键字声明的变量可以储存在CPU的寄存器中, 从而可以获得更快的读写速度
	因为存储在寄存器中, 因此无法获得寄存器变量的地址, 且无论是否成功的存入寄存器中, 都无法用地址运算符

三 具有代码块作用域的静态变量
	静态变量是指变量的地址保持不变, 而具有代码块作用域的静态变量, 只有代码块的作用域, 但在该代码块结束后并不消失, 该变量在下一次调用时, 仍具有上一次调用结束时的值
	该变量需要static关键字(使其获得静态存储时期), 并在代码块内部声明, 事实上该初始化语句仅仅被执行一次, 其后将被跳过

四 具有外部链接的静态变量
	具有文件作用域, 外部链接和静态存储时期, 该变量可以在所有函数的外部, 或者其他文件中定义
	如果在其他文件中定义, 则在这个文件中需要加上extern关键字声明一次
	如果在本文件的所有函数外部声明, 则用extern再次声明是可选的

五 具有内部链接的静态变量
	具有文件作用域, 内部链接和静态存储时期, 该变量需要在函数外部使用static关键字声明
	该变量基本上与具有外部链接的静态变量相同, 即, 也可以用extern再次声明, 但只能被本文件中的函数引用
注意 在声明变量时, 上述的register static extern关键字均在描述变量类型关键字前面

多文件
	当使用多个文件构成的程序时, 如果多个文件共用一个变量, 那么原则上, 其他文件中, 必须使用entern再次声明才能使用

函数存储类
外部的
	默认情况下, 函数存储类是外部的, 外部函数可被其他文件中的函数调用
	通常在使用另一个文件中的函数时, 用extern关键字再次声明, 以增强文件的可读性
静态的
	在函数声明是加上static关键字, 则函数只能被本文件的中的函数使用, 从而可以在不同文件中使用相同的函数名, 避免可能的名字冲突

随机函数
srand（（unsigned）time（NULL））；//播种子, 需要调用<time.h>
rand（）//输出整形数值
RAND_MAX 由<stdlib.h> 规定的rand()的最大值
（double）rand（）/RAND_MAX  则输出0到1的小数
rand（）%100 则返回0到99的随机数


产生一定范围随机数的通用表示公式
      要取得[a,b)的随机整数, 使用(rand() % (b-a))+ a （结果值含a不含b）. 
      要取得[a,b]的随机整数, 使用(rand() % (b-a+1))+ a （结果值含a和b）. 
      要取得(a,b]的随机整数, 使用(rand() % (b-a))+ a + 1 （结果值不含a含b）. 
      （总的来说, 通用公式：a + rand() % n ；其中的a是起始值, n是整数的范围）
      要取得a到b之间的随机整数, 另一种表示：a + (int)b * rand() / (RAND_MAX + 1). 
      要取得0～1之间的浮点数, 可以使用rand() / double(RAND_MAX). 



分配内存
	malloc()的参数是所需内存字节数, 返回指向该内存块的第一个字节的void指针, 在使用时, 需要将其强制类型转换为需要的指针类型, 获得地址的指针完全可以当做数组来操作
	calloc()需要两个参数, 第一个是需要元素的数量, 第二个是每个元素以字节计算的大小, 与malloc()相比, calloc()会将所有位置都置为0
	free()的参数是之前malloc()或者calloc()返回的指针, 为避免不必要的风险, free()释放后不再使用的指针应该赋值为NULL

exit()函数
	用于结束程序, 并关闭所有的文件, 可以使用一些不同的较小的数字作为参数, 以表示不同情况下的退出
	通常使用0, 表示正常结束, 其他值表示异常结束, 也可以使用stdlib.h中的宏
	使用EXIT_FAILURE和EXIT_SUCCESS作为参数
	使用EXIT_SUCCESS作为参数时, 表示程序正常结束, 与return 0;效果相似, 但不是结束函数, 而是结束程序
	使用EXIT_FAILUR作为参数时, 指示程序异常退出

关于堆栈的一些理解
	因为堆栈设定的先进后出的规则, 从而保证了内存中不会产生碎片

全局数据的使用
	在头文件中, 使用静态内部链接, 可以使该变量在多个文件中被包含时不产生冲突
	对于常量数据, 可以直接写入头文件, 然后每个文件都包含这个头文件

类型限定词
volatile
	告诉编译器该变量除了可被程序改变以外, 还可能被其他代理改变, 如果不使用这个关键词, 则默认变量只能被程序改变
restrict
	只能在指针声明时添加在指针前面, 表明这个指针是访问该数据的唯一方式
	在以指针为参数的函数中使用restrict可以要求用户输入两个所指的区域不同的指针

文本视图与二进制视图
	文本视图会将不同的方式储存的文件映射为C视图, 在储存时, 将C视图映射为本地环境表示的方法
	二进制视图会显示文本中的每一个字符, 而不产生任何映射
通常, 对文本文件使用文本视图, 对二进制文件使用二进制视图

文件指针
	是在stdio.h中定义的一种派生类型, 使用FILE关键字声明一个文件指针
	文件指针并非指向实际的文件, 而是指向一个关于文件的信息的数据包

标准文件
	C程序默认打开3个文件, 这3个文件被称为标准输入（standard input）标准输出（standard output）标准错误输出（standard error output）
	默认的标准输入是系统的一般输入设备, 通常为键盘
	默认的标准输出和标准错误输出是系统的一般输出设备, 通常为显示器
	使用标准错误输出是为了给产生的错误提供一个独立的输出, 这样使得输出被重定向至文件时, 错误仍能显示在屏幕上

fopen（）函数
	需要两个参数, 第一个是要打开的文件名, 第二个是指定文件打开模式的字符串
r	只读的打开文件
w	将文件清空后, 在写入文件, 如果文件不存在, 则创建该文件
a	以追加的形式写入文件, 如果文件不存在, 则创建该文件
r+	可以更新的打开一个文件, 即可读可写
w+	可以更新的打开一个文件, 如果文件存在, 则先清空, 如果文件不存在, 则创建该文件
a+	可以更新的打开一个文件, 如果文件存在, 则向文件末尾追加内容, 如果文件不存在, 则创建该文件
	在上述参数的末尾加上b, 则在相识模式下以二进制视图打开文件
	若函数成功打开一个文件, 则返回一个文件指针, 否则返回NULL

getc()函数与putc()函数
	两个函数与getchar()和putchar()相似
	ch=getc(fp)表示读取一个字符
	putc(ch, fp)表示向fp指向的文件写入一个字符

文件结尾
	当读取到文件结尾时, getc()返回EOF
	为了避免读入空文件带来的麻烦, 可以使用如下的形式
int ch;
FILE *fp;
fp=fopen("wacky.txt","r");
while((ch=getc(fp)) != EOF)
{
	putchar(ch);  //处理输出
}

fclose()函数
	参数是一个文件指针, 关闭由该指针指向的文件, 同时根据需要刷新缓冲区
	一个更正规的程序应该检查文件是否成功关闭, 成功则fclose()返回0, 否则返回EOF

标准文件指针
	stdin, stdout, stderr是FILE型指针

fprintf()函数与fscanf()函数
	两个函数与printf()和scanf()相似, 只是需要第一个参数来指定文件
	fscanf()返回有效读取的字符, 可以通过判断返回值是否大于零来判断是否达到文件末尾
	注意putc()将文件指针作为最后一个参数

rewind()函数
	需要一个文件指针作为参数, 使该指针回到文件开头处

fgets()函数
	fgets()函数有三个参数, 第一个是存放字符串的地址
	第二个是最大读入字符数, 如果参数为n, 则读取最多n-1个字符, 或者在之前遇到\n, 同时\n也会被读入到字符串中
	第三个是读取的文件的文件指针
	fgets()遇到EOF, 则返回NULL, 一次检验达到文件尾
	如果未达到最大字符限制, 则fgets()保留\n

fputs()函数
	fputs()函数第一个参数是字符串的地址
	第二个参数说明要写的文件的文件指针
	注意, 同类的put和get在有无\n上是配套

其他标准I/O函数
int ungetc(int c, FILE * fp)
	将c指定的字符放回fp对应的输入流中, 当下次读取时, 将首先读取到该字符
int fflush(FILE * fp)
	将缓冲区中任何未写的数据发送到一个由fp指定的输出文件中去, 从而对缓冲区刷新, 如果fp是一个输入流, 则该函数效果未被定义, 在某些编译器中, 代表刷新缓冲区
int setvbuf(FILE * restrict fp, char * restrict buf, int mode, size_t size)
	建立一个供标准I/O函数使用的替换缓冲区, 在打开文件以后且没有对流进行任何操作以前, 可以调用这个函数
	fp指定流, buf指向将使用的储存区, 如果buf值为NULL, 则函数自动分配一个缓冲区, size为指定缓冲区的大小
	mode从如下选项中选取
	_IOFBF		完全缓冲(缓冲区满后刷新)
	_IOLBF		行缓冲(输入一行或者缓冲区满后刷新)
	_IONBF		无缓冲
size_t fwrite(const void * restrict ptr, size_t size, size_t nmemb, FILE * restrict fp)
	ptr是要写入的数据的存储地址, size是数据块的大小, nmemb是数据块的数目, fp是写入的文件指针
size_t fread(void * restrict ptr, size_t size, size_t nmemb, FILE * restrict fp)
	fread()与fwrite()参数相同, 使用该函数可以读取由fwrite()存入的数据

关于循环输入的一种判断
	检查读入的字符串第一个字符是否为\0, 作为退出循环的标志, 此时对应用户直接输入回车


结构
struct 结构名称{
	成员1
	成员2
	.
	.
}；  //注意这里有分号	
	同结构变量之间可以相互赋值, 结构变量可以像数组一样的初始化

结构数组
	声明一个结构数组与声明一般类型的数组方法相同, 引用数组元素和结构中的成员的方式也是相同的
	声明一个比较大的结构数组时, 可能会导致堆栈溢出, 可以通过设置编译器选项来获得一个足够大的堆栈空间, 或者将数组设为静态或者外部的

结构嵌套
	在一个结构中可以嵌套另外一个结构声明和使用方法不变

指向结构的指针
	指向结构的指针的声明与普通指针相同, 但在赋值时要注意结构名并不代表其地址, 需要使用&
	指针只能使用->符号来访问结构中的元素
	对指针使用取内容运算符, 即*, 即等价于结构名, 从而可以使用.运算符

向函数传递结构
	函数可以把一个结构作为参数, 也可以把结构中的某个成员作为参数, 但参数传递的是数值
	如果在函数中需要改变结构的值, 则需要传递地址

关于结构的几个问题
一	结构还是结构指针
	对于较小的结构, 适合直接使用结构, 代码可读性高且操作简便
	对于较大的结构, 传递指针速度快且效率高
二	结构中使用字符数组还是字符指针
	因为字符指针的地址难以控制, 可能会导致不必要的麻烦, 因此尽量在结构内使用字符数组
	在某些情况下, 可以先读入数据, 然后malloc一块地址, 将数据复制到该内存块中, 最后使用结构中的字符指针指向该内存块

伸缩型数组成员
	定义一个结构, 该结构的最后一个元素是一个数组, 但是该数组的括号内是空的, 然后声明该类型的指针, 使用malloc为其分配足够常规成员和需要的伸缩型数组的空间, 其后使用该指针来访问数组成员

联合
	联合是一种能在同一储存空间里储存不同类型数据的数据结构, 设计它是用来以某种既没有规律, 事先也未知的顺序保存混合类型数据
union 标志符{
	成员1
	成员2
	.
	.
};     //注意此处的分号
	联合整体上与结构使用方式相同, 同一时间内只能存储某一类型的数据, 因此需要自己记住联合中存储的是什么数据

枚举
	枚举可以创建一个新的类型并指定它可以具有的值, 枚举类型的目的是提高程序的可读性
enum spectrum{red, green, blue};
enum spectrum color;
	之后可以使用诸如color=red一类的语句, red是一个int常量, 默认enum中的元素从0开始计数, 即red=0, green=1, blue=2
	在声明时, 使用red=10, 可以讲red的值设为10, 其他元素从10开始依次递增
	看起来enum类似于python中的dictionary
	使用枚举中的单词来代替数据进行逻辑判断比单纯的使用数字要更具有可读性, 注意枚举的单词只能在对应的变量上使用如果是输入, 直接输入数字或者进行转换

共享的名字空间
	结构, 联合, 枚举的标记共享同一个名字空间, 该空间与普通变量的名字空间不同, 因此在同一作用域下, 结构和普通变量可以使用同一个名字
	但是, 这样显然很容易产生混淆, 而且C++中不允许同一作用域下变量名字和结构标记相同

typedef用法简介
一 创建一个数据类型的别名, 例如
typedef struct complex{
	float real;
	float imag;
}COMPLEX;
	那么在后面的代码中就可以使用COMPLEX代替struct complex
	通常使用typedef创建的别名全部大写, 以提示用户这是某个名称的缩写
	
二 对复合类型进行掩饰, 例如
typedef char Line[81];
	那么Line就代表了具有81个元素的字符数组, 结构数组操作方式类似

三 未定义的名字
	可以使用typedef对未定义的名字进行替代, 这样可以创建指向结构自己的指针, 例如
typedef　struct　tagNode　pNode;
struct　tagNode{
char*　pItem;
pNode*　pNext;
};
	第一句typedef定义pNode时, tagNode还未定义, 但编译器允许这样的语句, 如果将两句话合在一起定义, 则编译器报错

四 其他更复杂情况自行百科

函数与指针
	指针需要与函数具有相同的参数, 使用函数名对指针进行复制, 
	可以使用（*p）（）或者p（）来调用函数, 但最好使用第一种方式


声明规则介绍
	[]和（）具有相同的优先级, 两者单独的结合或者混合的结合都是从左向右进行
int *p		int型指针p
int *p[n]	int型指针数组p
int (*p)[n]	指向int型数组元素的指针p
int *p()	返回值是指针的函数p
int (*p)()	指向函数的指针p
int **p		指向一个int指针变量的指针p

数字表示
	在代码中以0开头的数会当做八进制数来处理, 所以不要随便加0
	在代码中以0x开头的数会当作十六进制数来处理


位运算

一 位逻辑运算
1 取反		 ~
2 位与 		&
3 位或 		|
4 位异或	^
上述的四个符号与+, -, *, /一样可以与=结合从而简化表达式

二 掩码（MASK）
1 打开位
	通过a  ｜1等于1来实现
2 关闭位
	通过a & 0 等于0来实现
3转置位
	通过a ^ 1 等于~a来实现

三 移位运算符
1 左移  <<
	左边是要移动的对象, 右边是移动的位数, 空位用0填充
2 右移  >>
	左边是要移动的对象, 右边是移动的位数, 空位用0填充
注意, 移位不改变移动对象的值, 如需改变, 要使用=


明显常量 
#define定义宏
#define PI 3.14159	//PI是这个宏的名称, 3.14159是宏的值
注意：
    1.没有分号结尾, 因为其不是C的语句
    2.宏的值如果超过一排, 那么除最后一行的每行的最后要加\
    3.可以在宏中包含另外一个宏


在#define 中使用参数
#define SQUARE（X） （（X）*（X））
	在程序中可以使用SQUARE（2)来计算, 为了避免一些难以察觉的错误, 在使用宏参数时, 要尽可能的使用括号将参数括起来
	在引号引起的字符串中, 即使包含宏名, 也不会被替换, 如果想在字符串中包含宏参数, 可以将该宏参数单独拿出来, 并在前面加上#, 例如
#define PSQR（x） printf("The square of" #x "is %d.\n",((x)*(x)))

##运算符
	##运算符可以把两个语言符号组成单个语言符号, 例如
	#define XNAME(n) x ## n
	那么XNAME（4）将会被替换成x4

可变宏 ...和__VA_ARGS__（两边各有两个下划线）
	#define PR(...) printf(__VA_ARGS__)
	那么在PR中可以使用任意数量的参数, 他们将替换__VA_ARGS__

使用宏还是使用函数
	宏是用空间换时间, 与调用函数, 宏增加量内联代码的数量, 但是不产生程序控制的转移, 所以宏占用的更多空间而节省了时间
	宏不检查其中的变量类型, 因此无论是float还是double都可以使用SQUARE（）

文件包含
	include时用""则在.c的当前目录寻找, 如果没有再去编译器指定的位置去找, 如果用<>, 就直接去编译器指定的位置去找
	把函数原型, 明显常量, 宏函数, 结构模板定义放到一个头文件中, 在需要使用的地方include这个头文件, 就可以让编译器知道相关的信息

其他指令
#undef
	取消定义一个给定的#define
条件编译
#ifdef MAV
...
#else 
....
#endif
	如果MAV定义过, 则执行ifdef下面的语句, 否则执行else下面的语句

#ifndef
	和#ifdef是反义词, 可以用于防止一个常量被反复定义, 可以与#else #endif连用

使用如下的结构可以防止一个头文件被反复定义
#ifndef THINK_H_
	#define THINK_H_
	/*头文件的其他部分*/
#endif	

注意 C标准保留下划线开头的宏, 所以定义自己使用的宏时, 应避免这种用法

#if和#elif
	和if语句相识, 在#if语句后面跟上常量整数表达式, 如果表达式非零, 则表达式为真

defined（）预算符
	defined预算符是预处理器预算符, 参数是一个宏, 如果宏被定义过, 则返回1, 否则返回0, 使用该运算符可以和#elif一同使用

预定义宏
__DATE__	进行预处理的时间
__FILE__	代表当前源代码的文件名的字符串
__LINE__	代表当前源代码的行号的整形常量
__TIME__	代表编译时间

#line
	#line用于重置__FILE__和__LINE__宏报告的行号和文件名
	#line 1000 "a.c"    //将行号重置为1000将文件名重置为a.c

#error
	#error用于使编译器发出一个错误信息, 例如
#if __LINE__ != 100
	#error NOT 100
#endif

内联函数
	使用内联函数将向编译器建议尽可能快的调用该函数, 这将可能是编译器简化该函数的调用过程, 但也有可能没有作用
	创建内联函数的方法是在函数声明前面加上函数说明符inline
	编译器会将函数代码插入到对于的调用函数的位置
	内联函数无法获得地址, 实际上如果获得该函数的地址, 该函数将不会变成内联函数
	对于比较短小的函数适合使用内联函数, 较大的函数的调用时间相对于函数执行时间而言就相对较少了

通用工具库
atexit（）函数
	该函数使用一个函数指针作为参数, 可以使用函数名作为参数, 将该函数注册到exit（）函数的列表中, 在调用exit（）函数时, 会先调用在注册列表中的函数, ANSI保证该列表至少可以容纳32个函数
	在main函数结束后, 会自动调用exit（）函数

qsort（）函数
	void qsort(void *base,size_t nmemb,size_t size,int(*compar)(const void *,const void *))
	第一个参数指向要排序的数组的头部, 第二个参数为需要排序的数量, 第三个参数指示第一个指针的大小, 最后一个参数指向一个函数, 该函数接受两个参数, 并比较两个参数的大小, 如果第一个项目大于第二个项目, 则返回正数, 如果两个项目相等, 则返回0, 否则返回负数

诊断库
	具体内容自行google

memcpy（）和memmove（）
	参数与strcpy（）和strncpy（）相似, 每个函数还需要最后一个参数指示元素的总大小（SIZE*sizeof（））, 这两个函数用于对其他类型的数组的赋值和剪切

可变参数 stdarg.h
	具体内容自行google


链表与数组
	数组的优点是可以随机访问, 缺点是插入和删除元素很费时
	链表的优点是快速插入和删除元素, 缺点是不能提供随机访问




大程序结构
1.在DEV C++中新建一个项目, 然后把几个源代码文件加入进去, 即可把多个文件一起编译
2.把函数原型放到一个头文件中, 在需要调用函数的地方include这个头文件, 就可以让编译器知道函数原型
3.include时用“”再.c的当前目录寻找, 如果没有再去编译器指定的位置去找, 如果用<>, 就直接去编译器指定的位置去找. 
4.include也是预编译指令, 会把对应的文本原封不动的插入到代码中
5.一般的做法是所有的.c都有对应的.h来声明
6.在全局变量或函数前加入static, 那么它们就只能在所在的编译单元中使用
7.extern关键字用于声明全局变量, 使这个全局变量在多个.c中的可以被访问
8.规定只有声明可以放在头文件中, 否则容易产生重复声明




细节问题
1  i++等价于i=i+1
2  注释的方法
   // 或/*    */
3  i++  ：先在i所在的表达式中使用i的当前值, 后让i加1
   ++i  ：让i先加1, 然后在i所在的表达式中使用i的新值
4  强制类型转换是临时的, 所以在计算中即使是double的, 最后输出的是int, 那么看到的还是int
   如果表达式加了括号, 那么先计算括号中的值在强制转化, 不加括号则有优先级转换为最高级的数据    类型
5  逻辑相等要用两个等号
6  x-=y等价于x=x-y
7  i++就是语句执行完毕以后补做一个i=i+1的赋值, ++i就是在语句执行之前执行一个i=i+1语句
8  形式参数与实际参数是两套不同的参数, 用数值copy来获得数值, 因此函数内部的变化不会影响实际    参数, 但是可以通过指针直接在内存中修改, 以达到数据交换
9  数组在函数中时同一套. 
10 一维数组与指针相同


非常重要的问题
1  使用数组不要越界, 否则会产生意想不到的错误
2.在一个更小的地方定义的变量可以隐藏更大地方的变量, 例如局部变量比全局变量大
